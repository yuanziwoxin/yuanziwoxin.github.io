{"meta":{"title":"YuanTechnology","subtitle":null,"description":null,"author":"yuanziwoxin","url":"https://yuanziwoxin.github.io"},"pages":[{"title":"","date":"2018-01-31T08:29:46.335Z","updated":"2018-01-31T08:29:46.335Z","comments":true,"path":"comment-policy/index.html","permalink":"https://yuanziwoxin.github.io/comment-policy/index.html","excerpt":"","text":"Archives | YuanTechnology #container.show { background: linear-gradient(200deg,#a0cfe4,#e8c37e); } 评论政策 我们欢迎对我们的博客进行客观的讨论并提出建议；因此，我们积极鼓励评论。为确保尊重他人和公平交流思想与意见，请遵守以下指南： 评论仅是评论者的观点。每个网友对自己发表的内容负责。yuanziwoxin对内容的准确性和完整性不承担责任。 编辑部门有权删除主题、文章和评论，包括任何或所有的以下类型的内容： 商业的或私人的供应商，其商品或服务的连接与评论 滥用评论功能打广告 侮辱或歧视言论 种族主义、色情或淫秽内容 呼吁对人、机构或公司实施暴力 侮辱或侵犯第三方的权利 邀请示威和公告 引用他人文章时不提供来源或作者的名字"},{"title":"","date":"2018-01-31T09:42:20.672Z","updated":"2018-01-31T09:42:20.672Z","comments":true,"path":"tags/随笔/index.html","permalink":"https://yuanziwoxin.github.io/tags/随笔/index.html","excerpt":"","text":"Archives | YuanTechnology #container.show { background: linear-gradient(200deg,#a0cfe4,#e8c37e); } 待开发中...敬请期待..."}],"posts":[{"title":"Solidity学习笔记","slug":"Solidity学习笔记","date":"2019-04-19T01:35:02.000Z","updated":"2019-04-19T01:36:17.250Z","comments":true,"path":"2019/04/19/Solidity学习笔记/","link":"","permalink":"https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/","excerpt":"","text":"[TOC] 一、基本介绍Solidity是一门静态类型语言，支持继承、库和复杂的用户自定义类型等特性。 二、基础语法1. 地址（address） 以太坊中的地址为160位，即20个字节大小，所以可以用一个uint160表示。 eip-55:有关验证地址的合法性 在合约内部，this表示当前合约本身，由于合约也是一个address类型（contract是从address继承的），所以this其实也是address类型的值。2. 类型转换(1) 隐式转换（1）无符号整数（uint）可以转换为相同或更大尺寸的字节类型（bytes）,但是反过来不可以转换。（2）任何可以转换为uint160类型的变量都可以转换为地址类型（address）。123456789101112pragma solidity ^0.4.17;contract convert&#123; int8 a = 1; int16 b = 2; // 返回的类型必须是int16，如果返回int8类型会报错，这边运算符已经帮我们隐式转换了类型 function test() public view returns(int16) &#123; // a+b 的结果会隐式的转换为int16 return a + b; &#125;&#125; (2)显式转换123456int8 public c = -2;uint8 public d = uint8(c);// 此时的d为254uint public e = uint(c);// e = 115792089237316195423570985008687907853269984665640564039457584007913129639934 3. 发送以太币的两种方法（1）transfertransfer从合约发起方向某个地址转入以太币，当地址无效或者发起方余额不足时，transfer将抛出异常。123456// 向addressA转入一个以太币addressA.transfer(1 ether);// or // 附带 gasaddressA.transfer.gas(120000)(1 ether); （2）sendsend是transfer的低级版本。当合约执行失败时，send会返回false。当转账成功，则返回true。12345owner.send(SOME_BALANCE); // 失败时返回falseif(owner.send(SOME_BALANCE))&#123; ...&#125; 使用send时需注意以下三点： （1）send方法需包裹在if中，因为在调用send函数时，合约可能会有函数执行，这些函数可能会执行失败。 （2）在用send方法发送以太币之前，请先执行减少账户余额的操作，因为可能会有递归调用消耗完合约余额的风险。 （3）用户可以重载send方法。 总结：x.transfer(y)等价于if(!x.send(y)) throw; ,send是transfer的底层实现，建议尽可能使用transfer。 4. 字节数组（1）固定长字节数组固定长度字节数组是以bytes加上数字后缀的方式定义的。1234byte a; // byte 等同于bytes1 abytes2 b; ...bytes32 c; 索引访问：bytes1~bytes32 支持索引访问，但是这种索引访问是只读的，不能使用进行赋值。1234567bytes10 bb[0] // 获取第1个字节b[1] // 获取第2个字节...b[9] // 获取第9个字节b[0] = x // 不能使用索引的形式进行赋值，因为这种索引访问是只读的。 可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。 （2）动态长度字节数组bytes：动态长度字节数组一种特殊的数组。bytes类似于byte[]，在外部函数作为参数时，会进行压缩打包以便节省空间，所以尽量用bytes。1bytes m; string：动态长度字符数串 （1）字符串以UTF-8的形式编码 （2）类似bytes，但不提供长度和按索引的访问方式。12345678// 字符串是双引号string n = &quot;hello&quot;;// 不支持长度访问n.length// 不支持按索引访问n[0] （1） string不支持通过索引访问，但可以通过string类型的值转换为bytes类型的值，然后就可以使用索引访问字符串的特定字节。 （2） 由于bytes类型的值是可读写的，所以要修改string类型的值，可以先将string类型的值转换为bytes类型的值，修改完后，再将bytes类型的值转换为string类型的值。1value2 = typename ( value1 ); //类型转换 其中typename表示类型名，如string、bytes等。 string类型有一些缺陷：如，不能直接使用加号（+）进行连接，但可以通过bytes类型间接将两个或多个字符串连接起来。 字符串连接的基本原理： （1）创建一个尺寸与所有参与连接的字符串尺寸之和相同的大字符串； （2）将该大字符串转换为bytes类型； （3）依次迭代参与连接的字符串，将字符串中的字符逐一添加到bytes类型的值中； （4）将这个bytes类型的值转换为string类型的值。12345678910111213141516171819202122// internal表示函数只能被合约内部调用，函数在合约外不可见function strConcat(string memory _str1,string memory _str2) internal pure returns(string memory) &#123; // 先将string转化为bytes类型的值 bytes memory _bytesValue1 = bytes(_str1); bytes memory _bytesValue2 = bytes(_str2); // 创建一个能容纳_str1和_str2的string对象 string memory resultStr = new string(_bytesValue1.length + _bytesValue2.length); // 创建与_str1和_str2总和同样尺寸的bytes对象 bytes memory resultBytes = bytes(resultStr); uint index = 0; for(uint i=0;i&lt;_bytesValue1.length;i++)&#123; resultBytes[index++] = _bytesValue1[i]; &#125; for(uint i=0;i&lt;_bytesValue2.length;i++)&#123; resultBytes[index++] = _bytesValue2[i]; &#125; return string(resultBytes);&#125; 5. 枚举类型（enum）枚举是Solidity中的自定义数据类型。枚举可以显式转为整型，但是不能与整型隐式转换，枚举在一般程序中可以当作状态机使用。12// 定义枚举类型（类型名为enumName）enum enumName&#123; value1, value2, ... , valueN&#125; 例如：12345678910111213// 定义一个枚举类型名为Country的枚举类型，每一个枚举值都对应一个整数索引，China表示0，America表示1，以此类推。(不用添加分号) enum Country &#123;China,America,Japan,Australia,Canada,South_Korea&#125; // 定义枚举Country类型的变量 Country country; // 赋值 country = Country.China; //使用枚举值进行赋值 // or country = Country(0); //使用整数值进行赋值（必须显式类型转换） // 枚举可以显式转化为整型 uint currentCountry = uint(Country.China); // 0 注意： （1）在合约中可以使用枚举值设置枚举变量，也可以使用整数值设置枚举变量，后者必须显式类型转换。 （2）在remix环境中测试智能合约时，再输入测试数据时不能直接输入Country.China或其他枚举值，而需要输入整数，如0,1,2,3等。 6. 函数类型 （1）函数声明的类型称为函数类型。（注意：强调的是类型，类似我们常见的uint，string类型） （2）函数类型可以作为函数参数的类型和函数返回值的类型。 （3）只要函数的参数个数、参数类型和函数返回值与函数类型一样，该函数就可以赋给一个函数类型的变量。 123456789//func是一个函数类型变量function (uint,uint) returns(uint) func; function add(uint x, uint y) public returns(uint)&#123;return x+y;&#125;function test() public&#123;// 将add函数赋给函数类型变量funcfunc = add;&#125; 7. 函数和状态变量的4种可见性（访问权限）（1）访问权限（1） 如果不为函数指定访问权限，默认为public。（2） 合约的状态变量不能用external修饰，否则无法编译通过。（3） 如果不为状态变量指定访问权限，默认为internal。 4类可见性（访问权限） 指定： public：智能合约外部和内部都可使用的方法； 用public声明的状态变量，会自动产生一个getter函数。 internal：智能合约（包括派生合约，子合约）内部才可调用的方法；internal修饰的状态变量只能通过在内部的方式访问； external：可通过其他合约和交易进行调用的方法； （1）external函数不能直接调用，前面需要加this, 如this.func( )。（2）在接收大量数据时，external函数有时更有效率。 private：只有在定义的合约中才可以调用，即使派生的合约也无法调用；用private修饰的状态变量也是如此，只在当前合约中可以访问（子合约也不能访问）。（2）getter函数如果合约的状态变量使用public修饰，Solidity编译器会自动为状态变量生成一个与状态变量同名的getter函数，用于获取状态变量的值。 （1）如果状态变量的数据类型比较复杂，如mapping，生成的getter函数会带一些参数。 （2）尽管自动生成的getter函数使用external修饰，但是不能在合约内使用this调用。（尽管不会产生编译错误，但是无法成功部署合约） （3）在合约内部，getter函数会解析为状态变量。 例如，如果状态变量persons是mapping类型，在合约内部应该使用persons[key], 而不是this.persons(key)形式。不过在合约外部必须使用getter函数形式引用persons。（如：my.persons(key), my为创建的合约对象名，persons(key)即为状态变量persons的getter函数形式） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract MyContract&#123; uint public data = 115; string public personName; uint public personAge; struct Person&#123; string name; uint age; &#125; mapping(uint=&gt;Person) public persons; constructor() public&#123; data = 200; // 创建Person结构体的实例 Person memory person = Person(&#123; name:&quot;Lebron James&quot;, age:34 &#125;); // 将person添加到persons映射中 persons[10] = person; // 在合约内部不能使用persons的getter函数形式引用persons映射， // 所以尽管下面的代码编译不会出错，但无法成功部署在以太坊上。 // (string memory name,uint age) = this.persons(10); string memory name = persons[10].name; uint age = persons[10].age; personName = name; personAge = age; &#125;&#125;contract GetterContract&#123; MyContract my = new MyContract(); function getData() public view returns(uint)&#123; // 调用MyContract合约中的data状态变量对应的getter函数（data函数） return my.data(); &#125; function getPerson(uint id) public view returns(string memory,uint)&#123; // 调用MyContract合约中persons状态变量对应的getter函数（persons函数） // 该函数返回了多个值，这些值都是Person结构体的成员， // 如果这个结构体的某个成员的数据类型无法通过函数返回（如mapping），那么系统就会忽略这个结构体成员。 (string memory name,uint age) = my.persons(id); return (name,age); &#125;&#125; 8. 数组（稍有不同）（1）不同之处solidity中数组与大多数语言稍有不同。具体如下：1234// 定义一个j行i列的二维数组（注意：定义的时候列在前面，行在后面）int[i][j] arrayName;// 为数组arrayName的第m行第n列元素赋值，赋值为20.( 注意：赋值的时候，行在前面，列在后面)arrayName[m][n] = 20; （1）定义的时候列在前面，行在后面； （2）赋值的时候，行在前面，列在后面； （2）注意事项（一） 对于storage数组，可以保存任意类型的数据，包括另一个数组、映射或结构体。 但对于memory数组，不能存储映射类型的数据。 如果作为 public 函数的参数，它只能是 ABI 类型。（3）注意事项（二） （1） 如果你在一个空数组中使用.length，这将会造成向下溢出(不减小反而增大)，导致长度变为2^256-1。 （2） 增加一个storage数组的长度花费的gas成本是一个常量值，因为storage变量被当作是zero-initialised(领初始化)的；而减少storage数组的长度花费的gas成本至少是线性增长的（但事实上，大多数都要高于线性增长），因为其包含了显式清除要被删除的元素（类似于调用delete方法）。 （3） 外部函数中暂时还不支持使用多维数组（但在public函数是支持的）。（4）数组成员length数组的成员变量length表示当前数组的长度。 （1）动态数组可以在storage中通过改变成员变量 .length 改变数组大小（在memory中是不可以的）。 （2）并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。 （3）一经创建，memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。 （4）如果你尝试改变一个不在storage中的非动态数组的大小，你将会收到一个“Value must be an Ivalue”的错误。pushstorage的动态数组以及 bytes类型（字节数组）都有一个叫做 push 的成员函数，它用来添加新的元素到数组末尾。 这个函数将返回新的数组长度。 注意：string即字节数组是没有push方法的。 popstorage的动态数组和bytes数组（字节数组）都有一个叫做pop的成员函数，用于从数组的末尾删除元素。其在删除元素的时候隐式地调用了delete方法。注意：string即字节数组是没有pop方法的。 （5）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pragma solidity &gt;=0.4.16 &lt;0.7.0;contract ArrayContract &#123; uint[2**20] m_aLotOfIntegers; // 数组大小为2的20次方 // m_pairsOfFlags不是一对动态数组，而是一个数组元素为两个变量的动态数组（说白了就是其每个元素是一个长度为2的数组） bool[2][] m_pairsOfFlags; // 列数为2，行数为动态的 // newPairs是一个数组元素为两个bool类型变量的动态数组（其每个元素是一个包含两个bool变量的数组） function setAllFlagPairs(bool[2][] memory newPairs) public &#123; // 将newPairs数组赋值给storage数组的m_pairsOfFlags,m_pairsOfFlags的值将会被newPairs中的值替换。 m_pairsOfFlags = newPairs; &#125; struct StructType &#123; uint[] contents; uint moreInfo; &#125; StructType s; function f(uint[] memory c) public &#123; // 将类型为StructType结构体变量s的指针（引用）赋值给g StructType storage g = s; // 改变结构体变量g中的成员属性值，其实也在改变s中的成员属性值（因为s和g指向同一块数据区域） g.moreInfo = 2; // 将c的值赋值给g.contents（虽然g.contents不是一个局部变量，但它是某个局部变量的一个成员） g.contents = c; &#125; function setFlagPair(uint index, bool flagA, bool flagB) public &#123; // 访问一个不存在数组下标会抛异常 m_pairsOfFlags[index][0] = flagA; // 将flagA赋值给第index行第0列的元素 m_pairsOfFlags[index][1] = flagB; // 将flagB赋值给第index行第1列的元素 &#125; function changeFlagArraySize(uint newSize) public &#123; // 如果所赋给的新长度值小于原数组长度值，则会把原数组在新长度之外的元素删除。 m_pairsOfFlags.length = newSize; &#125; function clear() public &#123; // 将数组清空 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 与上面效果相同（清空数组） m_pairsOfFlags.length = 0; &#125; bytes m_byteData; function byteArrays(bytes memory data) public &#123; // 字节数组（bytes）是不一样的,因为它们不是填充式存储，但是它们可以被当作和uint8[]一样对待。 m_byteData = data; m_byteData.length += 7; m_byteData[3] = 0x08; delete m_byteData[2]; &#125; function addFlag(bool[2] memory flag) public returns (uint) &#123; return m_pairsOfFlags.push(flag); // 向二维动态数组添加新元素（这里添加的元素是一个长度为2的数组），给二维数组增加一行 &#125; function createMemoryArray(uint size) public pure returns (bytes memory) &#123; // 使用new关键字进行动态数组的创建 uint[2][] memory arrayOfPairs = new uint[2][](size); // 内联数组总是静态大小的，如果你只是使用字面量，则你必须提供至少一种类型。 arrayOfPairs[0] = [uint(1), 2]; // 创建一个动态数组 bytes memory b = new bytes(200); for (uint i = 0; i &lt; b.length; i++) b[i] = byte(uint8(i)); return b; &#125;&#125; 参考：Array 9. 结构体（struct）（1）定义结构体用于自定义数据类型，结构体成员可以是任何数据类型，甚至可以是结构体本身。 （1）结构体可用于函数返回值，但是要在智能合约内部调用，否则会抛出异常。 （2）如果要返回结构体中成员的值，可以使用返回多个值的函数。（2）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pragma solidity &gt;=0.4.16 &lt;= 0.7.0;contract StructContract_1&#123; // 定义结构体类型 struct Job&#123; uint id; string name; string company; &#125; struct Person&#123; uint id; string name; uint age; Job job; // 结构体类型中引用结构体变量（结构体变量作为结构体类型的成员） &#125; // Job public job; // 声明一个Person类型的变量 Person person; // 初始化结构体 // 方法一：按照结构体中命名参数进行初始化 Person personA = Person(&#123; id:10002, name:&quot;Kobe Bryant&quot;, age:39, job:Job(&#123; //结构体中包含结构体 id:102, name:&quot;Basketball Player&quot;, company:&quot;NBA&quot; &#125;) &#125;); // 方法二：按照结构体中定义的顺序初始化 Job jobA = Job(103,&quot;NBA Retired Players&quot;,&quot;Home&quot;); Person personB = Person(10003,&quot;Dwyane Wade&quot;,36,Job(104,&quot;LiNing Spokeman&quot;,&quot;LiNing&quot;)); Person personC = Person(10004,&quot;Chris Bosh&quot;,35,jobA); //通过构造函数初始化结构体类型变量 constructor (uint personId,string memory name,uint age) public&#123; // 初始化结构体变量 Job memory job = Job(&#123; id:101, name:&quot;Software Engineer&quot;, company:&quot;Google&quot; &#125;); person = Person(&#123; id:personId, name:name, age:age, job:job &#125;); &#125; // 修改工作属性（修改结构体变量的值） function setJob(string memory jobName,string memory company) public&#123; // job.name = jobName; // job.company = company; person.job.name = jobName; person.job.company = company; // 重置为初始值，把struct中的所有变量的值设置为0，除了mapping类型 // delete person; //也须写在函数内部 &#125; // 要用结构体当作返回值，必须将函数定义为internal，即合约内部可见（函数仅在合约内部可调用） // 必须在内部调用（需要使用internal声明函数），否则会抛出异常 function getPerson() internal view returns(Person memory)&#123; return person; // 返回构造体类型的值 &#125; // 获取人员的姓名、年龄、工作等信息（获取结构体的成员值） function callGetPerson() public returns(string memory,uint,string memory,string memory)&#123; person = getPerson(); return (person.name,person.age,person.job.name,person.job.company); &#125;&#125;// 1,&quot;Lebron James&quot;,34 &quot;BasketBall Player&quot;,&quot;NBA&quot; 10. 映射（mapping）（1）定义映射与字典类似，通过key获取对应的value值。 key：可以是除了映射外的任何数据类型； value：任何数据类型；1mapping(keyType=&gt;valueType) varName; （2）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity &gt;=0.4.16 &lt;=0.7.0;contract MappingContract&#123; //声明映射类型的变量names mapping(uint=&gt;string) public names; // 定义Person结构体类型 struct Person&#123; string name; uint age; string job; &#125; //声明映射类型的变量persons mapping(uint=&gt;Person) public persons; // 通过合约的构造函数向映射变量names添加值 constructor (uint id,string memory name) public&#123; names[id] = name; //映射变量的赋值 &#125; // 根据key值从映射类型变量中获取相应的value值 function getValue(uint id) public view returns(string memory)&#123; return names[id]; &#125; // 向映射类型变量中添加值 function addPerson(uint id,string memory name,uint age,string memory job) public&#123; // 先初始化结构体 Person memory person = Person(&#123; name:name, age:age, job:job &#125;); persons[id] = person; //增加一个person（向映射类型变量中添加值） &#125; // 根据id(key)从persons映射获取Person对象，并通过返回多值函数返回Person结构体的成员 function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123; // 返回多个值 // 方法一：多返回值函数可以通过定义具体的函数返回值接收多个返回值，而不使用return关键字 name = persons[id].name; age = persons[id].age; job = persons[id].job; // 方法二：使用return关键字(多个返回值，需用括号括起来) // return (persons[id].name,persons[id].age,persons[id].job); &#125;&#125;// 测试数据// 1001,&quot;Lebron James&quot;// 1002,&quot;Dwyane Wade&quot;,36,&quot;NBA Player&quot;// 1003,&quot;Kobe Bryant&quot;,39,&quot;World Cup Spokeman&quot; 实例中有提到两种不同的方式返回多个值 11.函数参数和函数返回值（1）函数参数在函数中，如果某个参数未使用，只需保留参数类型，参数名可以省略。 （2）函数返回值函数返回值可以直接指定返回值类型，也可以为返回值指定变量名，声明返回值类型的方式与声明函数参数的方式相同，所以也可以将函数返回值称为函数输出和参数。 返回值类型要使用returns指定，多个返回值类型中间用逗号（ , ）分隔； 如果为函数返回值指定变量名，可以不使用return返回，直接为函数输出参数变量赋值即可。 返回多个值的两种方法 方法一： 函数可以通过设置多个具体的函数返回值变量接收多个返回值，而不使用return关键字，就可实现多个值的返回。 123456 function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123; name = persons[id].name; age = persons[id].age; job = persons[id].job; &#125;&#125; 方法二： 使用return关键字(多个返回值，需用括号括起来) 1234 function getPerson(uint id) public view returns(string memory, uint ,string memory)&#123; return (persons[id].name,persons[id].age,persons[id].job); &#125;&#125; 12. 调用其他合约中的函数（1）定义当前合约中的函数调用其他合约中的函数的两个前提条件： （1）被调用函数所在的合约必须已经成功部署在以太坊网络上（或在本地的测试环境）。 （2）需要知道被调用函数所在的合约的地址。（2）实例1234567891011121314151617181920212223242526272829303132333435// CallOtherContract.solpragma solidity &gt;=0.4.16 &lt;=0.7.0;/**注意： （1）在部署FunCallContract之前，必须先部署FactorialContract合约，否则就无法获得FactorialContract的地址。 （2）部署完FactorialContract合约之后，将FactorialContract合约的地址作为FunCallContract合约的构造参数 传入FunCallContract合约，然后部署FunCallContract合约。 */// 用于计算阶乘的合约contract FactorialContract&#123; // 计算阶乘的函数 function getFactorial(uint n) public returns(uint)&#123; if(n==0 || n==1)&#123; return 1; &#125; else&#123; return getFactorial(n-1)*n; &#125; &#125;&#125;// 调用FactorialContract.getFactorial函数计算阶乘contract FunCallContract&#123; FactorialContract factorial; //在构造函数中创建FactorialContract合约的实例， // 必须通过FunCallContract构造函数的参数指定FactorialContract合约的地址。 constructor(address addr) public&#123; factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址 &#125; // 计算阶乘 function jiecheng(uint n) public returns(uint)&#123; return factorial.getFactorial(n); &#125;&#125; 12. 通过new关键字创建合约对象通过new关键字创建合约对象最大的优势：不需要先部署被调用函数所在的合约，并先获取被调用函数所在合约的地址，然后才能部署调用函数的合约。 换句话说就是，合约A调用合约B中的函数还需要先部署合约B是比较麻烦的。但是通过new关键字创建合约对象，则不需要部署合约B就可以调用B中的函数。 相对于上面CallOtherContract.sol的代码,只需将FunCallContract的构造函数123constructor(address addr) public&#123; factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址 &#125; 修改为12345// CallOtherContract_1.solconstructor() public&#123; // 通过new关键字创建合约对象（此时不需要传入该合约对象的合约地址） factorial = new FactorialContract(); &#125; 其他不用变化。 这样使用new关键字创建合约对象，就不需要先部署FactorialContract合约，并获取其合约的地址后，然后才能部署FunCallContract合约，在其合约内部调用其FactorialContract合约中的函数。这里可以直接部署FunCallContract合约。 13. 函数的命名参数在solidity语言中调用函数时可以指定命名参数，通过命名参数，可以不按被调用函数的参数的定义的顺序传入参数值。12345678910111213pragma solidity &gt;=0.4.16 &lt;=0.7.0;// 命名参数的使用contract NamedParameter&#123; function sub(int n1,int n2) public pure returns(int) &#123; return n1-n2; &#125; function fun() public pure returns(int)&#123; // 通过函数的命名参数，可以不按被调用函数中的参数的定义顺序进行赋值 // 命名参数要通过&#123;...&#125;传递，有点类似于javascript中的对象 return sub(&#123;n2:66,n1:32&#125;); &#125;&#125; 15. 函数多返回值解构和元组赋值 （1）多返回值解构：如果函数返回多个值，可以支持将多个返回值分别赋给相应数目的变量。 （2）元组赋值：指赋值运算符（=）左侧和右侧都有n个变量。123456789101112131415161718192021222324pragma solidity &gt;=0.4.24 &lt;=0.7.0; //注意：只有0.4.24及以上版本才支持多返回值解构和元组赋值contract AssignmentContract&#123; uint[] data; function mulValueFun() public pure returns(uint,bool,uint)&#123; return (2018,true,2019); &#125; function assignment() public returns(uint xx,uint yy,bool bb,uint length)&#123; // 多返回值解构赋值，x、b和y分别等于mulValueFun函数的3个返回值 (uint x,bool b,uint y) = mulValueFun(); // 交换x和y的值 (x,y)=(y,x); //元组赋值 // 这里只指定了一个变量（data.length）,所以mulValueFun函数的其他返回值会被忽略 (data.length,,) = mulValueFun(); //未指定的变量，通过逗号（,）将位置留着 // 重新设置y变量的值 y = 123; // 设置返回值 xx = x; yy = y; bb = b; length = data.length; &#125;&#125; 16. 变量声明和作用域（1）0.5.0版本之前在Solidity 0.5.0之前，Solidity语言的作用域规则继承自JavaScript。在if、while、for循环中定义的变量仍然作用于{…}外面，也就是说 {…}中声明的变量，在 {…}外仍然可以使用。换句话说，就是无论{..}内还是{…}外，都不能有同名的变量。 （2）0.5.0版本之后在Solidity 0.5.0之后, 开始支持声明块（{…}）变量，也就是在 {…}中声明的变量只在{…}中有效，这就意味着在多个{…}中可以声明多个同名的变量。 17. 错误处理Solidity语言有3种与错误处理相关的函数： （1）require：用于校检外部输入，如函数的参数、调用外部函数的返回值等。 （2）assert：用于校检合约的内部错误。 （3）revert：抛出错误。 Solidity语言的错误处理与数据库中的事务回滚类似，一旦发生错误，以前做的所有操作都将回滚，因为合约很可能涉及到转账等敏感操作，所以一旦有任何异常，必须全部恢复到最初的状态，以避免数据不一致的情况发生。 18. 全局变量（1）block变量123456789101112pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract BlockContract&#123; function getBlockInfo() public view returns(address coinbase,uint difficulty, uint gaslimit,uint number,uint timestamp)&#123; coinbase = block.coinbase; //获取挖出当前区块的矿工的地址； difficulty = block.difficulty; //获取当前区块的挖矿难度； gaslimit = block.gaslimit; //获取当前区块的gas限制； number = block.number; //获取当前区块的编号 timestamp = block.timestamp; //获取当前区块的时间戳（从Unix epoch即Unix纪元，从1970年1月1日开始） &#125;&#125; （2）msg变量 （1）执行函数包含参数：12345678910111213pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract MsgContract&#123; // 获取相关的系统信息 function getMsgInfo(uint x) public payable returns(bytes memory data,uint gas,address sender,bytes4 sig,uint value)&#123; data = msg.data; //获取当前执行函数的调用数据（包含函数标识，即sha3散列值的前8位，若执行函数有参数，则还包含参数值） // gas = msg.gas; // msg.gas已经被gasleft()函数取代 gas = gasleft(); // 获取剩余的gas sender = msg.sender; // 获取当前执行函数的调用地址 sig = msg.sig; // 获取当前执行函数的标识（sha3散列值的前8位） value = msg.value; // 当前被发送的wei的数量（使用该属性的函数要使用payable关键字修饰） &#125;&#125; 结果： （2）执行函数不包含参数： 把上述合约函数中的getMsgInfo(uint x)修改为getMsgInfo( ), 即去掉函数的参数。结果： msg.data表示当前执行函数的调用数据，包含函数标识（即sha3散列值的前8位）。如果执行函数包含参数，则其还包含参数值。 msg.sig表示当前执行函数的标识（即sha3散列值的前8位）。 换句话说，如果执行函数不包含参数，则msg.data(只包含函数标识)与msg.sig（函数标识）是一样的。 例如，若当前执行的函数是getMsgInfo( ),那么可以使用下面的Node.js代码获取该函数sha3散列值的前8位。该值与msg.data属性返回的值相同(即都是只包含函数标识)。12345var Web3 = require('Web3');web3 = new Web3( );// 由于sha3函数返回的值前两位是表示十六进制的0x,所以从第3个字符开始截取，截取的长度为8位sign = web3.sha3(\"getMsgInfo( )\").substr(2,8);console.log(sign); //输出 4c668374 （3）其他全局变量12345678910111213141516pragma solidity &gt;=0.4.22 &lt;=0.7.0;// 其他全局变量contract OtherGlobalContract&#123; // 获取其他全局变量的值 function getOtherGlobal() public view returns(bytes32 hash,uint nowTime,uint gasPrice,address origin)&#123; // 获取指定区块的哈希值（要传入区块号） hash = blockhash(1001); // 获取当前区块的时间戳（与block.timestamp属性返回的值相同） nowTime = now; // 获取交易的gas价格 gasPrice = tx.gasprice; // 获取发送交易的地址 origin = tx.origin; &#125;&#125; 19. 自定义修饰符（modifier）modifier常用于在函数执行前检查某种前置条件是否满足，modifier是一种合约属性，可以被继承（子合约可以使用父合约中定义的modifier），同时还可被派生的合约重写（override）。1234modifier modiferName&#123; //校检代码 _;&#125; 校检代码用于校检使用自定义修饰符的函数，后面必须跟一个下划线（_）,而且下划线后面跟分号（ ; ）。如果通过校检，将使用该定义修饰符的函数的函数体插入到下划线的位置。也可以认为自定义修饰符其实就是多个函数相同代码的抽象，除了校检代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263pragma solidity &gt;=0.4.20 &lt;0.7.0;contract OwnerContract&#123; address owner; // 保存部署合约的账号 constructor() public&#123; owner = msg.sender; &#125; // 定义用于检测msg.sender是否为部署合约的账号，如果不是，终止执行函数 modifier onlyOwner&#123; require(msg.sender == owner,&quot;Only owner can call this function.&quot;); _; // 如果校检通过，会将使用onlyOwner函数的函数体插到这个位置。 &#125; // 校检地址是否可以为空 // 当输入的_address为0x0000000000000000000000000000000000000000(0x后40个0)，会抛出“_address can not be 0!” modifier notNull(address _address)&#123; require(_address != address(0),&quot;_address can not be 0!&quot;); _; &#125; // 一个函数可以有多个修饰符，多个修饰符之间用空格或回车分隔，修饰符的生效顺序与定义顺序是一样的 // 修改合约所有者 function changeOwner(address newOwner) notNull(newOwner) onlyOwner() public&#123; owner = newOwner; &#125;&#125;//从OwnerContract继承 contract AddContract is OwnerContract&#123; // 使用onlyOwner修饰函数 function add(uint m,uint n) public view onlyOwner() returns(uint)&#123; return m+n; &#125;&#125;contract RestrictContract&#123; uint public mm; uint public nn; // 用于校检 m是否大于或等于n,如果不满足条件，相当于将使用restrict1函数的函数体删除 modifier restrict1(uint m,uint n)&#123; if(m&gt;=n)&#123; //如果不满足条件，相当于将使用restrict1函数的函数体删除 _; &#125; &#125; // 除了校检m是否大于n外，还将m和n分别保存在mm和nn变量中 modifier restrict2(uint m,uint n)&#123; require(m&gt;=n,&quot;m can not less than n&quot;); mm = m; nn = n; _; &#125;&#125;// 从RestrictContract合约继承contract SubContract is RestrictContract&#123; // 使用restrict1修饰sub1函数 function sub1(uint m,uint n) public pure restrict1(m,n) returns(uint)&#123; return m-n; &#125; // 使用restrict2修饰sub2函数 function sub2(uint m,uint n) public restrict2(m,n) returns(uint)&#123; return m-n; &#125;&#125; 20. pure和view（1）pure使用pure关键字修饰的函数不允许读写 状态变量，否则会编译出错。下面几种情况会被认为是读写状态变量，在这些情况下，用pure关键字修饰函数就会编译错误： （1）直接读取状态变量； （2）访问 this.balance或 .balance； （3）访问任何block、tx、msg变量中的成员，但msg.sig和msg.data除外。 （4）调用任何没有使用pure修饰的函数，哪怕是这个函数中确实没有读写任何状态变量。 （5）内嵌用于操作状态变量的汇编代码的函数。（2）view使用view关键字修饰函数时，表示该函数不会修改状态变量。下面几种情况表明函数会修改合约的状态变： （1）只写修改状态变量； （2）触发事件； （3）创建其他合约的实例； （4）调用selfdestruct函数销毁合约； （5）通过call函数方发送以太币； （6）调用任何未标记view或pure函数； （7）使用底层的call函数； （8）内嵌用于操作状态变量的汇编代码的函数； 需要注意的是：用view修饰的函数并不会阻止函数中修改状态变量，只是在用view修饰的函数中修改状态变量会出现警告。（不报错，只出现警告） 21. fallback函数（回调函数）*fallback函数：一个没有函数名、参数和返回值的函数。必须用external进行修饰。在下面两种情况下会调用fallback函数： （1） 合约中没有匹配的函数标识。 换句话说，就是 该合约没有其他函数； 调用合约时，如果没有匹配上该合约中的任何一个函数，就会调用回调函数。 （2） 合约接收到以太币（交易中没有附带任何其他数据），也会调用回调函数。 注意： 这种情况下，fallback函数要使用payable关键字修饰，否则给包含fallback函数的合约发送以太币时会出现编译错误。 即使 fallback 函数不能有参数，仍然可以使用 msg.data 来获取随调用提供的任何有效数据。 另外，还需注意以下几点： （1） 如果调用者想调用一个不存在的函数，fallback函数将会被执行。 （2） 如果你只想为了接收以太币而实现fallback函数，你需要增加一些校检（如 require(msg.data.length == 0 ) ）去避免一些无效的调用。 （3） 一个没有定义fallback函数（回调函数）的合约直接接收以太币（没有函数调用，如使用send或transfer），则会抛出一个异常，并返还以太币（有些行为在Solidity V0.4.0之前有些不同）。因此如果你要使你的合约接收以太币，你就必须实现一个被payable修饰的fallback函数。 一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 selfdestruct 的目标来接收以太币。 12345678910111213141516171819202122232425262728293031323334pragma solidity &gt;=0.5.0 &lt;=0.7.0;contract Test&#123; uint x; // （1）给这个合约发送任何消息都会调用这个函数（因为合约没有其他函数） // 定义一个fallback函数，在该函数中设置了状态变量x。 // （2）向这个合约发送以太币将会抛出一个异常，因为这个回调函数没有用“payable”修饰符修饰。 function() external&#123; x=101; &#125; &#125;contract Sink&#123; // 定义了一个fallback函数，该函数使用payable修饰，表明可以接受其他地址发过来的以太币。 function() external payable&#123; &#125;&#125;contract Caller&#123; function callTest(Test test) public returns(bool)&#123; // 这里调用一个不存在的函数，由于匹配不到函数，所以将调用Test合约中的回调函数。 (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExitingFunction()&quot;)); require(success); // address(test)不允许直接调用“send”方法，因为“test”没有被“payable”修饰的回调函数。 // 其必须通过“uint160”进行一个中间转换，然后再转换为“address payable”类型才能调用“send”方法。 address payable testPayable = address(uint160(address(test))); // 如果某人发送以太币给那个合约，这笔交易将会失败（例如，这里将会返回false） return testPayable.send(2 ether); &#125; function callSink(address payable sinkAddress) public returns(bool)&#123; Sink sink = Sink(sinkAddress); // 如果向Sink合约发送以太币时发送成功，Sink中的fallback函数会被调用 return address(sink).send(5 ether); &#125;&#125; 参考：Fallback Function 22. 函数重载（1）定义函数重载是指一个合约中定义了多个函数名相同，但参数个数和类型不同的函数。（不考虑返回值） 需要注意的是：如果函数参数类型是可以转换的，例如合约和address，Solidity编译器就会认为它们是同一个数据类型，因此会产生编译错误。 （2）实例1234567891011121314151617181920212223242526272829303132333435363738394041424344pragma solidity &gt;=0.4.20 &lt;=0.7.0;// 拥有4个同名的重载函数contract OverloadContract1&#123; // 拥有2个uint类型的参数 function add(uint m,uint n) public pure returns(uint)&#123; return m+n; &#125; // 没有参数 function add() public pure returns(uint)&#123; return 11+22; &#125; // 有一个bool类型参数 function add(bool b) public pure returns(bool)&#123; return b; &#125; // 有3个uint类型的参数 function add(uint l,uint m,uint n) public pure returns(uint)&#123; return l+m+n; &#125;&#125;contract A&#123;&#125;// 从表面上看第一个和第二个test函数的参数不一样，其实是一样的。因为合约A本身就是一个address类型// 所以OverloadContract2合约编译会失败，因为前两个test函数无法实现函数重载contract OverloadContract2&#123; // 函数重载失败 function test(address addr) public view returns(uint)&#123; return addr.balance; &#125; // 函数重载失败,具体报错：Function overload clash during conversion to external types for arguments. // function test(A a) public view returns(uint)&#123; // return address(a).balance; // &#125; // 函数重载成功 function test(A a,uint b) public view returns(uint,uint)&#123; return (address(a).balance,b); &#125; &#125; 23. 事件（event）（1）定义如果将合约部署在TestRPC环境或者以太坊网络上，在执行以太坊函数时是无法直接获得函数的返回值的，但是可以通过事件将计算结果返回给客户端。1event EventName( typeName parameter,... ); （2）实例1234567891011121314151617pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract EventContract&#123; // 定义MyEvent事件 event MyEvent( uint m, uint n, uint results ); function add(uint m,uint n) public returns(uint)&#123; uint results = m+n; // 使用emit指令触发MyEvent事件，并通过事件参数传递m、n和m+n的计算结果（传递到客户端） emit MyEvent(m,n,results); return results; &#125;&#125; 24. 合约继承合约继承，使用is关键字指定父合约。 （1） Solidity合约支持多继承，如果要指定多个合约，合约之间用逗号（ , ）分隔。 （2） 尽管可以指定多个父合约，但是只会创建一个合约实例，将其他父合约中的代码复制到这个合约实例中。 （3） 如果多个父合约实现了同样的函数，那么以最后一个父合约的函数为准。25. 合约构造函数 （1）老版本的solidity语言中，合约的构造函数与普通函数类似，只是函数名与合约名相同。 （2）新版本的solidity语言中，使用constructor作为构造函数的名字。 这样做的好处是，一旦改变了合约的名字，也不用修改其构造函数的名字。 （3）合约构造函数允许使用public或internal修饰。 123456789101112131415161718192021222324252627pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract Contract1&#123; uint public a; // 带参数的构造函数，假设用internal修饰 constructor(uint _a) internal&#123; a = _a; //用来初始化状态变量 &#125;&#125;// 从Contract1继承，并将构造函数重新用public修饰，变成外部可访问的构造函数。// 由于Contract1合约的构造函数有一个参数，所以在继承时需要指定Contract1合约构造函数的参数值。contract Contract2 is Contract1(100)&#123; constructor() public&#123; &#125;&#125;contract Contract3 is Contract1&#123; uint aa; uint bb; // 如果构造参数的参数需要用某些变量设置，如构造函数的参数，可以在构造函数后面指定父合约构造函数的参数值 constructor(uint _a,uint _b) Contract1(_a*_b) public&#123; aa = _a; bb = _b; &#125;&#125; 26. 抽象合约抽象合约： 至少有一个函数没有实现的合约。 如果合约从一个抽象合约继承，而且没有全部实现抽象合约中的函数，那么这个合约就会继承这些未实现的函数，所以这个合约也是抽象合约。（说白了，就是这个合约继承了一个抽象合约，但是还有些继承自抽象合约的函数没有实现，于是这个合约也就有了一些函数没有实现，所以这个合约也就是抽象合约了。） 抽象合约通常来实现多态，也就是用抽象合约的多个子合约创建多个实例，将这些实例赋给抽象合约类型的变量。由于这些子合约都实现了抽象合约中的函数，所以调用抽象合约中的函数会根据抽象合约类型变量的值不同，调用结果也不同，这就是称为多态。（调用同一个函数，会有多种不同表现形态）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051pragma solidity &gt;=0.5.0 &lt;=0.7.0;/** 在MyContract合约中的test1和test2函数中分别创建了 MyContract1和MyContract2的实例， 且将这两个合约的实例都赋值给了AbstractContract类型（抽象合约类型）的变量。 在test1和test2函数中都调用了AbstractContract合约（父合约）中的add函数，且输入相同的实参值， 不过返回结果却不一样，这就是多态。 实际上，本质上调用的是MyContract1（子合约）和MyContract2合约（子合约）中的add函数。 */contract AbstractContract&#123; // add函数没有实现 function add(uint m,uint n) public returns(uint); // 完整实现了sub函数 function sub(int m,int n) public pure returns(int)&#123; return m-n; &#125;&#125;// 该合约从AbstractContract继承(即MyContract1是AbstractContract的一个子合约)contract MyContract1 is AbstractContract&#123; // 实现了抽象合约中的add函数 function add(uint m,uint n) public returns(uint)&#123; return m+n; &#125;&#125;// 该合约从AbstractContract继承(即MyContract2是AbstractContract的另一个子合约)contract MyContract2 is AbstractContract&#123; // 实现了抽象合约中的add函数 function add(uint m,uint n) public returns(uint)&#123; return 4*(m+n); //不同于MyContract1中add函数的实现 &#125;&#125; // 该合约从MyContract1 继承，即继承了add函数和sub函数contract MyContract is MyContract1&#123; function test1(uint m,uint n) public returns(uint)&#123; // 创建MyContract1 合约的实例 AbstractContract abstractContract = new MyContract1(); // 实际是调用了MyContract1 合约中的add函数 return abstractContract.add(m,n); &#125; function test2(uint m,uint n) public returns(uint)&#123; // 创建MyContract2 合约的实例 AbstractContract abstractContract = new MyContract2(); // 实际是调用了MyContract1 合约中的add函数 return abstractContract.add(m,n); &#125;&#125; 27. 接口接口与抽象合约类似，但是不能实现任何函数。（即所有接口中的方法都是未实现的）此外，接口还有如下限制： （1）不能继承其他合约或接口； （2）不能定义构造函数； （3）不能定义变量； （4）不能定义结构体； （5）不能定义枚举类型。123interface interfaceName&#123; //抽象方法（未被实现的方法）&#125; 注意：（1）接口应该定义在合约的外部（与合约是同一等级）；（2）接口中定义的方法必须被external修饰； 合约实现接口的方法与继承合约或抽象合约的方法类似, 使用is关键字.12345678910111213141516pragma solidity &gt;=0.5.0 &lt;=0.7.0;// 定义接口(定义在合约外面)interface MyInterface&#123; function add(uint m,uint n) external returns(uint); function sub(int m,int n) external returns(int);&#125;// InterfaceContract实现了MyInterfacecontract InterfaceContract is MyInterface&#123; function add(uint m,uint n) public returns(uint)&#123; return m+n; &#125; function sub(int m,int n) public returns(int)&#123; return m-n; &#125;&#125; 28. gas limit和gas price（1）gas limit （1） gas limit 表示完成转账交易最大消耗的gas数，如果超过这个gas数，交易就会失败，整个交易过程都会回滚。 （2） gas limit 主要是为了防止由于发布交易消耗过多的gas。（2）gas price 表示你愿意为单位gas支付的费用，以gwei为单位表示。1 gwei = 10^9 wei（3）两者的作用 （1）在交易中gasPrice是由发起交易人来决定的，每个矿工接收到交易请求之后，会根据gasPrice的高低来决定是否要打包进区块。 （2）每个交易中必须包含gas limit和gas price的值。gas limit代表了这个交易执行过程中最多被允许消耗的gas数量。 （3）gas limit和gas price 代表着交易发送者愿意为执行交易支付的wei的最大值。付款金额（单位 wei）= Gas数量 × GasPrice （4）交易执行完成后，如果实际消耗的gas小于gaslimit，那么剩余的gas会以Ether的方式返回给交易发起者。 （5）如果在交易过程中，实际消耗的gas大于gas limit,那么就会出现“gas不足”的错误，这种情况下交易会被终止，交易之前的所有修改的状态会被回滚，同时在交易执行过程中所消耗的gas是不会回退给交易发起者的。","categories":[],"tags":[]},{"title":"Solidity学习笔记","slug":"Solidity学习笔记-1","date":"2019-04-19T01:35:02.000Z","updated":"2019-04-19T01:45:48.340Z","comments":true,"path":"2019/04/19/Solidity学习笔记-1/","link":"","permalink":"https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记-1/","excerpt":"本人学习过程中整理的Solidity笔记，仅供参考！","text":"本人学习过程中整理的Solidity笔记，仅供参考！ [TOC] 一、基本介绍Solidity是一门静态类型语言，支持继承、库和复杂的用户自定义类型等特性。 二、基础语法1. 地址（address） 以太坊中的地址为160位，即20个字节大小，所以可以用一个uint160表示。 eip-55:有关验证地址的合法性 在合约内部，this表示当前合约本身，由于合约也是一个address类型（contract是从address继承的），所以this其实也是address类型的值。2. 类型转换(1) 隐式转换（1）无符号整数（uint）可以转换为相同或更大尺寸的字节类型（bytes）,但是反过来不可以转换。（2）任何可以转换为uint160类型的变量都可以转换为地址类型（address）。123456789101112pragma solidity ^0.4.17;contract convert&#123; int8 a = 1; int16 b = 2; // 返回的类型必须是int16，如果返回int8类型会报错，这边运算符已经帮我们隐式转换了类型 function test() public view returns(int16) &#123; // a+b 的结果会隐式的转换为int16 return a + b; &#125;&#125; (2)显式转换123456int8 public c = -2;uint8 public d = uint8(c);// 此时的d为254uint public e = uint(c);// e = 115792089237316195423570985008687907853269984665640564039457584007913129639934 3. 发送以太币的两种方法（1）transfertransfer从合约发起方向某个地址转入以太币，当地址无效或者发起方余额不足时，transfer将抛出异常。123456// 向addressA转入一个以太币addressA.transfer(1 ether);// or // 附带 gasaddressA.transfer.gas(120000)(1 ether); （2）sendsend是transfer的低级版本。当合约执行失败时，send会返回false。当转账成功，则返回true。12345owner.send(SOME_BALANCE); // 失败时返回falseif(owner.send(SOME_BALANCE))&#123; ...&#125; 使用send时需注意以下三点： （1）send方法需包裹在if中，因为在调用send函数时，合约可能会有函数执行，这些函数可能会执行失败。 （2）在用send方法发送以太币之前，请先执行减少账户余额的操作，因为可能会有递归调用消耗完合约余额的风险。 （3）用户可以重载send方法。 总结：x.transfer(y)等价于if(!x.send(y)) throw; ,send是transfer的底层实现，建议尽可能使用transfer。 4. 字节数组（1）固定长字节数组固定长度字节数组是以bytes加上数字后缀的方式定义的。1234byte a; // byte 等同于bytes1 abytes2 b; ...bytes32 c; 索引访问：bytes1~bytes32 支持索引访问，但是这种索引访问是只读的，不能使用进行赋值。1234567bytes10 bb[0] // 获取第1个字节b[1] // 获取第2个字节...b[9] // 获取第9个字节b[0] = x // 不能使用索引的形式进行赋值，因为这种索引访问是只读的。 可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。 （2）动态长度字节数组bytes：动态长度字节数组一种特殊的数组。bytes类似于byte[]，在外部函数作为参数时，会进行压缩打包以便节省空间，所以尽量用bytes。1bytes m; string：动态长度字符数串 （1）字符串以UTF-8的形式编码 （2）类似bytes，但不提供长度和按索引的访问方式。12345678// 字符串是双引号string n = &quot;hello&quot;;// 不支持长度访问n.length// 不支持按索引访问n[0] （1） string不支持通过索引访问，但可以通过string类型的值转换为bytes类型的值，然后就可以使用索引访问字符串的特定字节。 （2） 由于bytes类型的值是可读写的，所以要修改string类型的值，可以先将string类型的值转换为bytes类型的值，修改完后，再将bytes类型的值转换为string类型的值。1value2 = typename ( value1 ); //类型转换 其中typename表示类型名，如string、bytes等。 string类型有一些缺陷：如，不能直接使用加号（+）进行连接，但可以通过bytes类型间接将两个或多个字符串连接起来。 字符串连接的基本原理： （1）创建一个尺寸与所有参与连接的字符串尺寸之和相同的大字符串； （2）将该大字符串转换为bytes类型； （3）依次迭代参与连接的字符串，将字符串中的字符逐一添加到bytes类型的值中； （4）将这个bytes类型的值转换为string类型的值。12345678910111213141516171819202122// internal表示函数只能被合约内部调用，函数在合约外不可见function strConcat(string memory _str1,string memory _str2) internal pure returns(string memory) &#123; // 先将string转化为bytes类型的值 bytes memory _bytesValue1 = bytes(_str1); bytes memory _bytesValue2 = bytes(_str2); // 创建一个能容纳_str1和_str2的string对象 string memory resultStr = new string(_bytesValue1.length + _bytesValue2.length); // 创建与_str1和_str2总和同样尺寸的bytes对象 bytes memory resultBytes = bytes(resultStr); uint index = 0; for(uint i=0;i&lt;_bytesValue1.length;i++)&#123; resultBytes[index++] = _bytesValue1[i]; &#125; for(uint i=0;i&lt;_bytesValue2.length;i++)&#123; resultBytes[index++] = _bytesValue2[i]; &#125; return string(resultBytes);&#125; 5. 枚举类型（enum）枚举是Solidity中的自定义数据类型。枚举可以显式转为整型，但是不能与整型隐式转换，枚举在一般程序中可以当作状态机使用。12// 定义枚举类型（类型名为enumName）enum enumName&#123; value1, value2, ... , valueN&#125; 例如：12345678910111213// 定义一个枚举类型名为Country的枚举类型，每一个枚举值都对应一个整数索引，China表示0，America表示1，以此类推。(不用添加分号) enum Country &#123;China,America,Japan,Australia,Canada,South_Korea&#125; // 定义枚举Country类型的变量 Country country; // 赋值 country = Country.China; //使用枚举值进行赋值 // or country = Country(0); //使用整数值进行赋值（必须显式类型转换） // 枚举可以显式转化为整型 uint currentCountry = uint(Country.China); // 0 注意： （1）在合约中可以使用枚举值设置枚举变量，也可以使用整数值设置枚举变量，后者必须显式类型转换。 （2）在remix环境中测试智能合约时，再输入测试数据时不能直接输入Country.China或其他枚举值，而需要输入整数，如0,1,2,3等。 6. 函数类型 （1）函数声明的类型称为函数类型。（注意：强调的是类型，类似我们常见的uint，string类型） （2）函数类型可以作为函数参数的类型和函数返回值的类型。 （3）只要函数的参数个数、参数类型和函数返回值与函数类型一样，该函数就可以赋给一个函数类型的变量。 123456789//func是一个函数类型变量function (uint,uint) returns(uint) func; function add(uint x, uint y) public returns(uint)&#123;return x+y;&#125;function test() public&#123;// 将add函数赋给函数类型变量funcfunc = add;&#125; 7. 函数和状态变量的4种可见性（访问权限）（1）访问权限（1） 如果不为函数指定访问权限，默认为public。（2） 合约的状态变量不能用external修饰，否则无法编译通过。（3） 如果不为状态变量指定访问权限，默认为internal。 4类可见性（访问权限） 指定： public：智能合约外部和内部都可使用的方法； 用public声明的状态变量，会自动产生一个getter函数。 internal：智能合约（包括派生合约，子合约）内部才可调用的方法；internal修饰的状态变量只能通过在内部的方式访问； external：可通过其他合约和交易进行调用的方法； （1）external函数不能直接调用，前面需要加this, 如this.func( )。（2）在接收大量数据时，external函数有时更有效率。 private：只有在定义的合约中才可以调用，即使派生的合约也无法调用；用private修饰的状态变量也是如此，只在当前合约中可以访问（子合约也不能访问）。（2）getter函数如果合约的状态变量使用public修饰，Solidity编译器会自动为状态变量生成一个与状态变量同名的getter函数，用于获取状态变量的值。 （1）如果状态变量的数据类型比较复杂，如mapping，生成的getter函数会带一些参数。 （2）尽管自动生成的getter函数使用external修饰，但是不能在合约内使用this调用。（尽管不会产生编译错误，但是无法成功部署合约） （3）在合约内部，getter函数会解析为状态变量。 例如，如果状态变量persons是mapping类型，在合约内部应该使用persons[key], 而不是this.persons(key)形式。不过在合约外部必须使用getter函数形式引用persons。（如：my.persons(key), my为创建的合约对象名，persons(key)即为状态变量persons的getter函数形式） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract MyContract&#123; uint public data = 115; string public personName; uint public personAge; struct Person&#123; string name; uint age; &#125; mapping(uint=&gt;Person) public persons; constructor() public&#123; data = 200; // 创建Person结构体的实例 Person memory person = Person(&#123; name:&quot;Lebron James&quot;, age:34 &#125;); // 将person添加到persons映射中 persons[10] = person; // 在合约内部不能使用persons的getter函数形式引用persons映射， // 所以尽管下面的代码编译不会出错，但无法成功部署在以太坊上。 // (string memory name,uint age) = this.persons(10); string memory name = persons[10].name; uint age = persons[10].age; personName = name; personAge = age; &#125;&#125;contract GetterContract&#123; MyContract my = new MyContract(); function getData() public view returns(uint)&#123; // 调用MyContract合约中的data状态变量对应的getter函数（data函数） return my.data(); &#125; function getPerson(uint id) public view returns(string memory,uint)&#123; // 调用MyContract合约中persons状态变量对应的getter函数（persons函数） // 该函数返回了多个值，这些值都是Person结构体的成员， // 如果这个结构体的某个成员的数据类型无法通过函数返回（如mapping），那么系统就会忽略这个结构体成员。 (string memory name,uint age) = my.persons(id); return (name,age); &#125;&#125; 8. 数组（稍有不同）（1）不同之处solidity中数组与大多数语言稍有不同。具体如下：1234// 定义一个j行i列的二维数组（注意：定义的时候列在前面，行在后面）int[i][j] arrayName;// 为数组arrayName的第m行第n列元素赋值，赋值为20.( 注意：赋值的时候，行在前面，列在后面)arrayName[m][n] = 20; （1）定义的时候列在前面，行在后面； （2）赋值的时候，行在前面，列在后面； （2）注意事项（一） 对于storage数组，可以保存任意类型的数据，包括另一个数组、映射或结构体。 但对于memory数组，不能存储映射类型的数据。 如果作为 public 函数的参数，它只能是 ABI 类型。（3）注意事项（二） （1） 如果你在一个空数组中使用.length，这将会造成向下溢出(不减小反而增大)，导致长度变为2^256-1。 （2） 增加一个storage数组的长度花费的gas成本是一个常量值，因为storage变量被当作是zero-initialised(领初始化)的；而减少storage数组的长度花费的gas成本至少是线性增长的（但事实上，大多数都要高于线性增长），因为其包含了显式清除要被删除的元素（类似于调用delete方法）。 （3） 外部函数中暂时还不支持使用多维数组（但在public函数是支持的）。（4）数组成员length数组的成员变量length表示当前数组的长度。 （1）动态数组可以在storage中通过改变成员变量 .length 改变数组大小（在memory中是不可以的）。 （2）并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。 （3）一经创建，memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。 （4）如果你尝试改变一个不在storage中的非动态数组的大小，你将会收到一个“Value must be an Ivalue”的错误。pushstorage的动态数组以及 bytes类型（字节数组）都有一个叫做 push 的成员函数，它用来添加新的元素到数组末尾。 这个函数将返回新的数组长度。 注意：string即字节数组是没有push方法的。 popstorage的动态数组和bytes数组（字节数组）都有一个叫做pop的成员函数，用于从数组的末尾删除元素。其在删除元素的时候隐式地调用了delete方法。注意：string即字节数组是没有pop方法的。 （5）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pragma solidity &gt;=0.4.16 &lt;0.7.0;contract ArrayContract &#123; uint[2**20] m_aLotOfIntegers; // 数组大小为2的20次方 // m_pairsOfFlags不是一对动态数组，而是一个数组元素为两个变量的动态数组（说白了就是其每个元素是一个长度为2的数组） bool[2][] m_pairsOfFlags; // 列数为2，行数为动态的 // newPairs是一个数组元素为两个bool类型变量的动态数组（其每个元素是一个包含两个bool变量的数组） function setAllFlagPairs(bool[2][] memory newPairs) public &#123; // 将newPairs数组赋值给storage数组的m_pairsOfFlags,m_pairsOfFlags的值将会被newPairs中的值替换。 m_pairsOfFlags = newPairs; &#125; struct StructType &#123; uint[] contents; uint moreInfo; &#125; StructType s; function f(uint[] memory c) public &#123; // 将类型为StructType结构体变量s的指针（引用）赋值给g StructType storage g = s; // 改变结构体变量g中的成员属性值，其实也在改变s中的成员属性值（因为s和g指向同一块数据区域） g.moreInfo = 2; // 将c的值赋值给g.contents（虽然g.contents不是一个局部变量，但它是某个局部变量的一个成员） g.contents = c; &#125; function setFlagPair(uint index, bool flagA, bool flagB) public &#123; // 访问一个不存在数组下标会抛异常 m_pairsOfFlags[index][0] = flagA; // 将flagA赋值给第index行第0列的元素 m_pairsOfFlags[index][1] = flagB; // 将flagB赋值给第index行第1列的元素 &#125; function changeFlagArraySize(uint newSize) public &#123; // 如果所赋给的新长度值小于原数组长度值，则会把原数组在新长度之外的元素删除。 m_pairsOfFlags.length = newSize; &#125; function clear() public &#123; // 将数组清空 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 与上面效果相同（清空数组） m_pairsOfFlags.length = 0; &#125; bytes m_byteData; function byteArrays(bytes memory data) public &#123; // 字节数组（bytes）是不一样的,因为它们不是填充式存储，但是它们可以被当作和uint8[]一样对待。 m_byteData = data; m_byteData.length += 7; m_byteData[3] = 0x08; delete m_byteData[2]; &#125; function addFlag(bool[2] memory flag) public returns (uint) &#123; return m_pairsOfFlags.push(flag); // 向二维动态数组添加新元素（这里添加的元素是一个长度为2的数组），给二维数组增加一行 &#125; function createMemoryArray(uint size) public pure returns (bytes memory) &#123; // 使用new关键字进行动态数组的创建 uint[2][] memory arrayOfPairs = new uint[2][](size); // 内联数组总是静态大小的，如果你只是使用字面量，则你必须提供至少一种类型。 arrayOfPairs[0] = [uint(1), 2]; // 创建一个动态数组 bytes memory b = new bytes(200); for (uint i = 0; i &lt; b.length; i++) b[i] = byte(uint8(i)); return b; &#125;&#125; 参考：Array 9. 结构体（struct）（1）定义结构体用于自定义数据类型，结构体成员可以是任何数据类型，甚至可以是结构体本身。 （1）结构体可用于函数返回值，但是要在智能合约内部调用，否则会抛出异常。 （2）如果要返回结构体中成员的值，可以使用返回多个值的函数。（2）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pragma solidity &gt;=0.4.16 &lt;= 0.7.0;contract StructContract_1&#123; // 定义结构体类型 struct Job&#123; uint id; string name; string company; &#125; struct Person&#123; uint id; string name; uint age; Job job; // 结构体类型中引用结构体变量（结构体变量作为结构体类型的成员） &#125; // Job public job; // 声明一个Person类型的变量 Person person; // 初始化结构体 // 方法一：按照结构体中命名参数进行初始化 Person personA = Person(&#123; id:10002, name:&quot;Kobe Bryant&quot;, age:39, job:Job(&#123; //结构体中包含结构体 id:102, name:&quot;Basketball Player&quot;, company:&quot;NBA&quot; &#125;) &#125;); // 方法二：按照结构体中定义的顺序初始化 Job jobA = Job(103,&quot;NBA Retired Players&quot;,&quot;Home&quot;); Person personB = Person(10003,&quot;Dwyane Wade&quot;,36,Job(104,&quot;LiNing Spokeman&quot;,&quot;LiNing&quot;)); Person personC = Person(10004,&quot;Chris Bosh&quot;,35,jobA); //通过构造函数初始化结构体类型变量 constructor (uint personId,string memory name,uint age) public&#123; // 初始化结构体变量 Job memory job = Job(&#123; id:101, name:&quot;Software Engineer&quot;, company:&quot;Google&quot; &#125;); person = Person(&#123; id:personId, name:name, age:age, job:job &#125;); &#125; // 修改工作属性（修改结构体变量的值） function setJob(string memory jobName,string memory company) public&#123; // job.name = jobName; // job.company = company; person.job.name = jobName; person.job.company = company; // 重置为初始值，把struct中的所有变量的值设置为0，除了mapping类型 // delete person; //也须写在函数内部 &#125; // 要用结构体当作返回值，必须将函数定义为internal，即合约内部可见（函数仅在合约内部可调用） // 必须在内部调用（需要使用internal声明函数），否则会抛出异常 function getPerson() internal view returns(Person memory)&#123; return person; // 返回构造体类型的值 &#125; // 获取人员的姓名、年龄、工作等信息（获取结构体的成员值） function callGetPerson() public returns(string memory,uint,string memory,string memory)&#123; person = getPerson(); return (person.name,person.age,person.job.name,person.job.company); &#125;&#125;// 1,&quot;Lebron James&quot;,34 &quot;BasketBall Player&quot;,&quot;NBA&quot; 10. 映射（mapping）（1）定义映射与字典类似，通过key获取对应的value值。 key：可以是除了映射外的任何数据类型； value：任何数据类型；1mapping(keyType=&gt;valueType) varName; （2）实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity &gt;=0.4.16 &lt;=0.7.0;contract MappingContract&#123; //声明映射类型的变量names mapping(uint=&gt;string) public names; // 定义Person结构体类型 struct Person&#123; string name; uint age; string job; &#125; //声明映射类型的变量persons mapping(uint=&gt;Person) public persons; // 通过合约的构造函数向映射变量names添加值 constructor (uint id,string memory name) public&#123; names[id] = name; //映射变量的赋值 &#125; // 根据key值从映射类型变量中获取相应的value值 function getValue(uint id) public view returns(string memory)&#123; return names[id]; &#125; // 向映射类型变量中添加值 function addPerson(uint id,string memory name,uint age,string memory job) public&#123; // 先初始化结构体 Person memory person = Person(&#123; name:name, age:age, job:job &#125;); persons[id] = person; //增加一个person（向映射类型变量中添加值） &#125; // 根据id(key)从persons映射获取Person对象，并通过返回多值函数返回Person结构体的成员 function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123; // 返回多个值 // 方法一：多返回值函数可以通过定义具体的函数返回值接收多个返回值，而不使用return关键字 name = persons[id].name; age = persons[id].age; job = persons[id].job; // 方法二：使用return关键字(多个返回值，需用括号括起来) // return (persons[id].name,persons[id].age,persons[id].job); &#125;&#125;// 测试数据// 1001,&quot;Lebron James&quot;// 1002,&quot;Dwyane Wade&quot;,36,&quot;NBA Player&quot;// 1003,&quot;Kobe Bryant&quot;,39,&quot;World Cup Spokeman&quot; 实例中有提到两种不同的方式返回多个值 11.函数参数和函数返回值（1）函数参数在函数中，如果某个参数未使用，只需保留参数类型，参数名可以省略。 （2）函数返回值函数返回值可以直接指定返回值类型，也可以为返回值指定变量名，声明返回值类型的方式与声明函数参数的方式相同，所以也可以将函数返回值称为函数输出和参数。 返回值类型要使用returns指定，多个返回值类型中间用逗号（ , ）分隔； 如果为函数返回值指定变量名，可以不使用return返回，直接为函数输出参数变量赋值即可。 返回多个值的两种方法 方法一： 函数可以通过设置多个具体的函数返回值变量接收多个返回值，而不使用return关键字，就可实现多个值的返回。 123456 function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123; name = persons[id].name; age = persons[id].age; job = persons[id].job; &#125;&#125; 方法二： 使用return关键字(多个返回值，需用括号括起来) 1234 function getPerson(uint id) public view returns(string memory, uint ,string memory)&#123; return (persons[id].name,persons[id].age,persons[id].job); &#125;&#125; 12. 调用其他合约中的函数（1）定义当前合约中的函数调用其他合约中的函数的两个前提条件： （1）被调用函数所在的合约必须已经成功部署在以太坊网络上（或在本地的测试环境）。 （2）需要知道被调用函数所在的合约的地址。（2）实例1234567891011121314151617181920212223242526272829303132333435// CallOtherContract.solpragma solidity &gt;=0.4.16 &lt;=0.7.0;/**注意： （1）在部署FunCallContract之前，必须先部署FactorialContract合约，否则就无法获得FactorialContract的地址。 （2）部署完FactorialContract合约之后，将FactorialContract合约的地址作为FunCallContract合约的构造参数 传入FunCallContract合约，然后部署FunCallContract合约。 */// 用于计算阶乘的合约contract FactorialContract&#123; // 计算阶乘的函数 function getFactorial(uint n) public returns(uint)&#123; if(n==0 || n==1)&#123; return 1; &#125; else&#123; return getFactorial(n-1)*n; &#125; &#125;&#125;// 调用FactorialContract.getFactorial函数计算阶乘contract FunCallContract&#123; FactorialContract factorial; //在构造函数中创建FactorialContract合约的实例， // 必须通过FunCallContract构造函数的参数指定FactorialContract合约的地址。 constructor(address addr) public&#123; factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址 &#125; // 计算阶乘 function jiecheng(uint n) public returns(uint)&#123; return factorial.getFactorial(n); &#125;&#125; 12. 通过new关键字创建合约对象通过new关键字创建合约对象最大的优势：不需要先部署被调用函数所在的合约，并先获取被调用函数所在合约的地址，然后才能部署调用函数的合约。 换句话说就是，合约A调用合约B中的函数还需要先部署合约B是比较麻烦的。但是通过new关键字创建合约对象，则不需要部署合约B就可以调用B中的函数。 相对于上面CallOtherContract.sol的代码,只需将FunCallContract的构造函数123constructor(address addr) public&#123; factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址 &#125; 修改为12345// CallOtherContract_1.solconstructor() public&#123; // 通过new关键字创建合约对象（此时不需要传入该合约对象的合约地址） factorial = new FactorialContract(); &#125; 其他不用变化。 这样使用new关键字创建合约对象，就不需要先部署FactorialContract合约，并获取其合约的地址后，然后才能部署FunCallContract合约，在其合约内部调用其FactorialContract合约中的函数。这里可以直接部署FunCallContract合约。 13. 函数的命名参数在solidity语言中调用函数时可以指定命名参数，通过命名参数，可以不按被调用函数的参数的定义的顺序传入参数值。12345678910111213pragma solidity &gt;=0.4.16 &lt;=0.7.0;// 命名参数的使用contract NamedParameter&#123; function sub(int n1,int n2) public pure returns(int) &#123; return n1-n2; &#125; function fun() public pure returns(int)&#123; // 通过函数的命名参数，可以不按被调用函数中的参数的定义顺序进行赋值 // 命名参数要通过&#123;...&#125;传递，有点类似于javascript中的对象 return sub(&#123;n2:66,n1:32&#125;); &#125;&#125; 15. 函数多返回值解构和元组赋值 （1）多返回值解构：如果函数返回多个值，可以支持将多个返回值分别赋给相应数目的变量。 （2）元组赋值：指赋值运算符（=）左侧和右侧都有n个变量。123456789101112131415161718192021222324pragma solidity &gt;=0.4.24 &lt;=0.7.0; //注意：只有0.4.24及以上版本才支持多返回值解构和元组赋值contract AssignmentContract&#123; uint[] data; function mulValueFun() public pure returns(uint,bool,uint)&#123; return (2018,true,2019); &#125; function assignment() public returns(uint xx,uint yy,bool bb,uint length)&#123; // 多返回值解构赋值，x、b和y分别等于mulValueFun函数的3个返回值 (uint x,bool b,uint y) = mulValueFun(); // 交换x和y的值 (x,y)=(y,x); //元组赋值 // 这里只指定了一个变量（data.length）,所以mulValueFun函数的其他返回值会被忽略 (data.length,,) = mulValueFun(); //未指定的变量，通过逗号（,）将位置留着 // 重新设置y变量的值 y = 123; // 设置返回值 xx = x; yy = y; bb = b; length = data.length; &#125;&#125; 16. 变量声明和作用域（1）0.5.0版本之前在Solidity 0.5.0之前，Solidity语言的作用域规则继承自JavaScript。在if、while、for循环中定义的变量仍然作用于{…}外面，也就是说 {…}中声明的变量，在 {…}外仍然可以使用。换句话说，就是无论{..}内还是{…}外，都不能有同名的变量。 （2）0.5.0版本之后在Solidity 0.5.0之后, 开始支持声明块（{…}）变量，也就是在 {…}中声明的变量只在{…}中有效，这就意味着在多个{…}中可以声明多个同名的变量。 17. 错误处理Solidity语言有3种与错误处理相关的函数： （1）require：用于校检外部输入，如函数的参数、调用外部函数的返回值等。 （2）assert：用于校检合约的内部错误。 （3）revert：抛出错误。 Solidity语言的错误处理与数据库中的事务回滚类似，一旦发生错误，以前做的所有操作都将回滚，因为合约很可能涉及到转账等敏感操作，所以一旦有任何异常，必须全部恢复到最初的状态，以避免数据不一致的情况发生。 18. 全局变量（1）block变量123456789101112pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract BlockContract&#123; function getBlockInfo() public view returns(address coinbase,uint difficulty, uint gaslimit,uint number,uint timestamp)&#123; coinbase = block.coinbase; //获取挖出当前区块的矿工的地址； difficulty = block.difficulty; //获取当前区块的挖矿难度； gaslimit = block.gaslimit; //获取当前区块的gas限制； number = block.number; //获取当前区块的编号 timestamp = block.timestamp; //获取当前区块的时间戳（从Unix epoch即Unix纪元，从1970年1月1日开始） &#125;&#125; （2）msg变量 （1）执行函数包含参数：12345678910111213pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract MsgContract&#123; // 获取相关的系统信息 function getMsgInfo(uint x) public payable returns(bytes memory data,uint gas,address sender,bytes4 sig,uint value)&#123; data = msg.data; //获取当前执行函数的调用数据（包含函数标识，即sha3散列值的前8位，若执行函数有参数，则还包含参数值） // gas = msg.gas; // msg.gas已经被gasleft()函数取代 gas = gasleft(); // 获取剩余的gas sender = msg.sender; // 获取当前执行函数的调用地址 sig = msg.sig; // 获取当前执行函数的标识（sha3散列值的前8位） value = msg.value; // 当前被发送的wei的数量（使用该属性的函数要使用payable关键字修饰） &#125;&#125; 结果： （2）执行函数不包含参数： 把上述合约函数中的getMsgInfo(uint x)修改为getMsgInfo( ), 即去掉函数的参数。结果： msg.data表示当前执行函数的调用数据，包含函数标识（即sha3散列值的前8位）。如果执行函数包含参数，则其还包含参数值。 msg.sig表示当前执行函数的标识（即sha3散列值的前8位）。 换句话说，如果执行函数不包含参数，则msg.data(只包含函数标识)与msg.sig（函数标识）是一样的。 例如，若当前执行的函数是getMsgInfo( ),那么可以使用下面的Node.js代码获取该函数sha3散列值的前8位。该值与msg.data属性返回的值相同(即都是只包含函数标识)。12345var Web3 = require('Web3');web3 = new Web3( );// 由于sha3函数返回的值前两位是表示十六进制的0x,所以从第3个字符开始截取，截取的长度为8位sign = web3.sha3(\"getMsgInfo( )\").substr(2,8);console.log(sign); //输出 4c668374 （3）其他全局变量12345678910111213141516pragma solidity &gt;=0.4.22 &lt;=0.7.0;// 其他全局变量contract OtherGlobalContract&#123; // 获取其他全局变量的值 function getOtherGlobal() public view returns(bytes32 hash,uint nowTime,uint gasPrice,address origin)&#123; // 获取指定区块的哈希值（要传入区块号） hash = blockhash(1001); // 获取当前区块的时间戳（与block.timestamp属性返回的值相同） nowTime = now; // 获取交易的gas价格 gasPrice = tx.gasprice; // 获取发送交易的地址 origin = tx.origin; &#125;&#125; 19. 自定义修饰符（modifier）modifier常用于在函数执行前检查某种前置条件是否满足，modifier是一种合约属性，可以被继承（子合约可以使用父合约中定义的modifier），同时还可被派生的合约重写（override）。1234modifier modiferName&#123; //校检代码 _;&#125; 校检代码用于校检使用自定义修饰符的函数，后面必须跟一个下划线（_）,而且下划线后面跟分号（ ; ）。如果通过校检，将使用该定义修饰符的函数的函数体插入到下划线的位置。也可以认为自定义修饰符其实就是多个函数相同代码的抽象，除了校检代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263pragma solidity &gt;=0.4.20 &lt;0.7.0;contract OwnerContract&#123; address owner; // 保存部署合约的账号 constructor() public&#123; owner = msg.sender; &#125; // 定义用于检测msg.sender是否为部署合约的账号，如果不是，终止执行函数 modifier onlyOwner&#123; require(msg.sender == owner,&quot;Only owner can call this function.&quot;); _; // 如果校检通过，会将使用onlyOwner函数的函数体插到这个位置。 &#125; // 校检地址是否可以为空 // 当输入的_address为0x0000000000000000000000000000000000000000(0x后40个0)，会抛出“_address can not be 0!” modifier notNull(address _address)&#123; require(_address != address(0),&quot;_address can not be 0!&quot;); _; &#125; // 一个函数可以有多个修饰符，多个修饰符之间用空格或回车分隔，修饰符的生效顺序与定义顺序是一样的 // 修改合约所有者 function changeOwner(address newOwner) notNull(newOwner) onlyOwner() public&#123; owner = newOwner; &#125;&#125;//从OwnerContract继承 contract AddContract is OwnerContract&#123; // 使用onlyOwner修饰函数 function add(uint m,uint n) public view onlyOwner() returns(uint)&#123; return m+n; &#125;&#125;contract RestrictContract&#123; uint public mm; uint public nn; // 用于校检 m是否大于或等于n,如果不满足条件，相当于将使用restrict1函数的函数体删除 modifier restrict1(uint m,uint n)&#123; if(m&gt;=n)&#123; //如果不满足条件，相当于将使用restrict1函数的函数体删除 _; &#125; &#125; // 除了校检m是否大于n外，还将m和n分别保存在mm和nn变量中 modifier restrict2(uint m,uint n)&#123; require(m&gt;=n,&quot;m can not less than n&quot;); mm = m; nn = n; _; &#125;&#125;// 从RestrictContract合约继承contract SubContract is RestrictContract&#123; // 使用restrict1修饰sub1函数 function sub1(uint m,uint n) public pure restrict1(m,n) returns(uint)&#123; return m-n; &#125; // 使用restrict2修饰sub2函数 function sub2(uint m,uint n) public restrict2(m,n) returns(uint)&#123; return m-n; &#125;&#125; 20. pure和view（1）pure使用pure关键字修饰的函数不允许读写 状态变量，否则会编译出错。下面几种情况会被认为是读写状态变量，在这些情况下，用pure关键字修饰函数就会编译错误： （1）直接读取状态变量； （2）访问 this.balance或 .balance； （3）访问任何block、tx、msg变量中的成员，但msg.sig和msg.data除外。 （4）调用任何没有使用pure修饰的函数，哪怕是这个函数中确实没有读写任何状态变量。 （5）内嵌用于操作状态变量的汇编代码的函数。（2）view使用view关键字修饰函数时，表示该函数不会修改状态变量。下面几种情况表明函数会修改合约的状态变： （1）只写修改状态变量； （2）触发事件； （3）创建其他合约的实例； （4）调用selfdestruct函数销毁合约； （5）通过call函数方发送以太币； （6）调用任何未标记view或pure函数； （7）使用底层的call函数； （8）内嵌用于操作状态变量的汇编代码的函数； 需要注意的是：用view修饰的函数并不会阻止函数中修改状态变量，只是在用view修饰的函数中修改状态变量会出现警告。（不报错，只出现警告） 21. fallback函数（回调函数）*fallback函数：一个没有函数名、参数和返回值的函数。必须用external进行修饰。在下面两种情况下会调用fallback函数： （1） 合约中没有匹配的函数标识。 换句话说，就是 该合约没有其他函数； 调用合约时，如果没有匹配上该合约中的任何一个函数，就会调用回调函数。 （2） 合约接收到以太币（交易中没有附带任何其他数据），也会调用回调函数。 注意： 这种情况下，fallback函数要使用payable关键字修饰，否则给包含fallback函数的合约发送以太币时会出现编译错误。 即使 fallback 函数不能有参数，仍然可以使用 msg.data 来获取随调用提供的任何有效数据。 另外，还需注意以下几点： （1） 如果调用者想调用一个不存在的函数，fallback函数将会被执行。 （2） 如果你只想为了接收以太币而实现fallback函数，你需要增加一些校检（如 require(msg.data.length == 0 ) ）去避免一些无效的调用。 （3） 一个没有定义fallback函数（回调函数）的合约直接接收以太币（没有函数调用，如使用send或transfer），则会抛出一个异常，并返还以太币（有些行为在Solidity V0.4.0之前有些不同）。因此如果你要使你的合约接收以太币，你就必须实现一个被payable修饰的fallback函数。 一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 selfdestruct 的目标来接收以太币。 12345678910111213141516171819202122232425262728293031323334pragma solidity &gt;=0.5.0 &lt;=0.7.0;contract Test&#123; uint x; // （1）给这个合约发送任何消息都会调用这个函数（因为合约没有其他函数） // 定义一个fallback函数，在该函数中设置了状态变量x。 // （2）向这个合约发送以太币将会抛出一个异常，因为这个回调函数没有用“payable”修饰符修饰。 function() external&#123; x=101; &#125; &#125;contract Sink&#123; // 定义了一个fallback函数，该函数使用payable修饰，表明可以接受其他地址发过来的以太币。 function() external payable&#123; &#125;&#125;contract Caller&#123; function callTest(Test test) public returns(bool)&#123; // 这里调用一个不存在的函数，由于匹配不到函数，所以将调用Test合约中的回调函数。 (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExitingFunction()&quot;)); require(success); // address(test)不允许直接调用“send”方法，因为“test”没有被“payable”修饰的回调函数。 // 其必须通过“uint160”进行一个中间转换，然后再转换为“address payable”类型才能调用“send”方法。 address payable testPayable = address(uint160(address(test))); // 如果某人发送以太币给那个合约，这笔交易将会失败（例如，这里将会返回false） return testPayable.send(2 ether); &#125; function callSink(address payable sinkAddress) public returns(bool)&#123; Sink sink = Sink(sinkAddress); // 如果向Sink合约发送以太币时发送成功，Sink中的fallback函数会被调用 return address(sink).send(5 ether); &#125;&#125; 参考：Fallback Function 22. 函数重载（1）定义函数重载是指一个合约中定义了多个函数名相同，但参数个数和类型不同的函数。（不考虑返回值） 需要注意的是：如果函数参数类型是可以转换的，例如合约和address，Solidity编译器就会认为它们是同一个数据类型，因此会产生编译错误。 （2）实例1234567891011121314151617181920212223242526272829303132333435363738394041424344pragma solidity &gt;=0.4.20 &lt;=0.7.0;// 拥有4个同名的重载函数contract OverloadContract1&#123; // 拥有2个uint类型的参数 function add(uint m,uint n) public pure returns(uint)&#123; return m+n; &#125; // 没有参数 function add() public pure returns(uint)&#123; return 11+22; &#125; // 有一个bool类型参数 function add(bool b) public pure returns(bool)&#123; return b; &#125; // 有3个uint类型的参数 function add(uint l,uint m,uint n) public pure returns(uint)&#123; return l+m+n; &#125;&#125;contract A&#123;&#125;// 从表面上看第一个和第二个test函数的参数不一样，其实是一样的。因为合约A本身就是一个address类型// 所以OverloadContract2合约编译会失败，因为前两个test函数无法实现函数重载contract OverloadContract2&#123; // 函数重载失败 function test(address addr) public view returns(uint)&#123; return addr.balance; &#125; // 函数重载失败,具体报错：Function overload clash during conversion to external types for arguments. // function test(A a) public view returns(uint)&#123; // return address(a).balance; // &#125; // 函数重载成功 function test(A a,uint b) public view returns(uint,uint)&#123; return (address(a).balance,b); &#125; &#125; 23. 事件（event）（1）定义如果将合约部署在TestRPC环境或者以太坊网络上，在执行以太坊函数时是无法直接获得函数的返回值的，但是可以通过事件将计算结果返回给客户端。1event EventName( typeName parameter,... ); （2）实例1234567891011121314151617pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract EventContract&#123; // 定义MyEvent事件 event MyEvent( uint m, uint n, uint results ); function add(uint m,uint n) public returns(uint)&#123; uint results = m+n; // 使用emit指令触发MyEvent事件，并通过事件参数传递m、n和m+n的计算结果（传递到客户端） emit MyEvent(m,n,results); return results; &#125;&#125; 24. 合约继承合约继承，使用is关键字指定父合约。 （1） Solidity合约支持多继承，如果要指定多个合约，合约之间用逗号（ , ）分隔。 （2） 尽管可以指定多个父合约，但是只会创建一个合约实例，将其他父合约中的代码复制到这个合约实例中。 （3） 如果多个父合约实现了同样的函数，那么以最后一个父合约的函数为准。25. 合约构造函数 （1）老版本的solidity语言中，合约的构造函数与普通函数类似，只是函数名与合约名相同。 （2）新版本的solidity语言中，使用constructor作为构造函数的名字。 这样做的好处是，一旦改变了合约的名字，也不用修改其构造函数的名字。 （3）合约构造函数允许使用public或internal修饰。 123456789101112131415161718192021222324252627pragma solidity &gt;=0.4.20 &lt;=0.7.0;contract Contract1&#123; uint public a; // 带参数的构造函数，假设用internal修饰 constructor(uint _a) internal&#123; a = _a; //用来初始化状态变量 &#125;&#125;// 从Contract1继承，并将构造函数重新用public修饰，变成外部可访问的构造函数。// 由于Contract1合约的构造函数有一个参数，所以在继承时需要指定Contract1合约构造函数的参数值。contract Contract2 is Contract1(100)&#123; constructor() public&#123; &#125;&#125;contract Contract3 is Contract1&#123; uint aa; uint bb; // 如果构造参数的参数需要用某些变量设置，如构造函数的参数，可以在构造函数后面指定父合约构造函数的参数值 constructor(uint _a,uint _b) Contract1(_a*_b) public&#123; aa = _a; bb = _b; &#125;&#125; 26. 抽象合约抽象合约： 至少有一个函数没有实现的合约。 如果合约从一个抽象合约继承，而且没有全部实现抽象合约中的函数，那么这个合约就会继承这些未实现的函数，所以这个合约也是抽象合约。（说白了，就是这个合约继承了一个抽象合约，但是还有些继承自抽象合约的函数没有实现，于是这个合约也就有了一些函数没有实现，所以这个合约也就是抽象合约了。） 抽象合约通常来实现多态，也就是用抽象合约的多个子合约创建多个实例，将这些实例赋给抽象合约类型的变量。由于这些子合约都实现了抽象合约中的函数，所以调用抽象合约中的函数会根据抽象合约类型变量的值不同，调用结果也不同，这就是称为多态。（调用同一个函数，会有多种不同表现形态）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051pragma solidity &gt;=0.5.0 &lt;=0.7.0;/** 在MyContract合约中的test1和test2函数中分别创建了 MyContract1和MyContract2的实例， 且将这两个合约的实例都赋值给了AbstractContract类型（抽象合约类型）的变量。 在test1和test2函数中都调用了AbstractContract合约（父合约）中的add函数，且输入相同的实参值， 不过返回结果却不一样，这就是多态。 实际上，本质上调用的是MyContract1（子合约）和MyContract2合约（子合约）中的add函数。 */contract AbstractContract&#123; // add函数没有实现 function add(uint m,uint n) public returns(uint); // 完整实现了sub函数 function sub(int m,int n) public pure returns(int)&#123; return m-n; &#125;&#125;// 该合约从AbstractContract继承(即MyContract1是AbstractContract的一个子合约)contract MyContract1 is AbstractContract&#123; // 实现了抽象合约中的add函数 function add(uint m,uint n) public returns(uint)&#123; return m+n; &#125;&#125;// 该合约从AbstractContract继承(即MyContract2是AbstractContract的另一个子合约)contract MyContract2 is AbstractContract&#123; // 实现了抽象合约中的add函数 function add(uint m,uint n) public returns(uint)&#123; return 4*(m+n); //不同于MyContract1中add函数的实现 &#125;&#125; // 该合约从MyContract1 继承，即继承了add函数和sub函数contract MyContract is MyContract1&#123; function test1(uint m,uint n) public returns(uint)&#123; // 创建MyContract1 合约的实例 AbstractContract abstractContract = new MyContract1(); // 实际是调用了MyContract1 合约中的add函数 return abstractContract.add(m,n); &#125; function test2(uint m,uint n) public returns(uint)&#123; // 创建MyContract2 合约的实例 AbstractContract abstractContract = new MyContract2(); // 实际是调用了MyContract1 合约中的add函数 return abstractContract.add(m,n); &#125;&#125; 27. 接口接口与抽象合约类似，但是不能实现任何函数。（即所有接口中的方法都是未实现的）此外，接口还有如下限制： （1）不能继承其他合约或接口； （2）不能定义构造函数； （3）不能定义变量； （4）不能定义结构体； （5）不能定义枚举类型。123interface interfaceName&#123; //抽象方法（未被实现的方法）&#125; 注意：（1）接口应该定义在合约的外部（与合约是同一等级）；（2）接口中定义的方法必须被external修饰； 合约实现接口的方法与继承合约或抽象合约的方法类似, 使用is关键字.12345678910111213141516pragma solidity &gt;=0.5.0 &lt;=0.7.0;// 定义接口(定义在合约外面)interface MyInterface&#123; function add(uint m,uint n) external returns(uint); function sub(int m,int n) external returns(int);&#125;// InterfaceContract实现了MyInterfacecontract InterfaceContract is MyInterface&#123; function add(uint m,uint n) public returns(uint)&#123; return m+n; &#125; function sub(int m,int n) public returns(int)&#123; return m-n; &#125;&#125; 28. gas limit和gas price（1）gas limit （1） gas limit 表示完成转账交易最大消耗的gas数，如果超过这个gas数，交易就会失败，整个交易过程都会回滚。 （2） gas limit 主要是为了防止由于发布交易消耗过多的gas。（2）gas price 表示你愿意为单位gas支付的费用，以gwei为单位表示。1 gwei = 10^9 wei（3）两者的作用 （1）在交易中gasPrice是由发起交易人来决定的，每个矿工接收到交易请求之后，会根据gasPrice的高低来决定是否要打包进区块。 （2）每个交易中必须包含gas limit和gas price的值。gas limit代表了这个交易执行过程中最多被允许消耗的gas数量。 （3）gas limit和gas price 代表着交易发送者愿意为执行交易支付的wei的最大值。付款金额（单位 wei）= Gas数量 × GasPrice （4）交易执行完成后，如果实际消耗的gas小于gaslimit，那么剩余的gas会以Ether的方式返回给交易发起者。 （5）如果在交易过程中，实际消耗的gas大于gas limit,那么就会出现“gas不足”的错误，这种情况下交易会被终止，交易之前的所有修改的状态会被回滚，同时在交易执行过程中所消耗的gas是不会回退给交易发起者的。","categories":[],"tags":[]},{"title":"C语言学习笔记","slug":"C语言笔记","date":"2018-02-02T03:04:13.745Z","updated":"2019-04-19T01:15:52.421Z","comments":true,"path":"2018/02/02/C语言笔记/","link":"","permalink":"https://yuanziwoxin.github.io/2018/02/02/C语言笔记/","excerpt":"这是C语言学习笔记(一)，仅供参考！","text":"这是C语言学习笔记(一)，仅供参考！ 1.输入a和b两个整数,按先大后小的顺序输出a和b方法一： 利用改变指针变量的值来实现（即改变指针的指向）123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*输入a和b两个整数，按先大后小的顺序输出a和b; 方法一：利用改变指针变量的值来实现（即改变指针的指向） */ int main() &#123; int *p1,*p2,a,b; int *temp; printf(\"Please enter two numbers:\"); scanf(\"%d %d\",&amp;a,&amp;b);//注意在运行时，输入数据的格式要和scanf中的格式相同； p1=&amp;a; p2=&amp;b; if(a&lt;b) &#123; temp=p1; p1=p2; p2=temp; &#125; printf(\"Max=%d,Min=%d\",*p1,*p2); return 0;&#125; 方法二： 利用交换指针变量指向的变量值（即交换a和b的值）1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*方法二：利用交换指针变量指向的变量值（即交换a和b的值） */int main()&#123; int *p1,*p2,a,b; int temp; printf(\"Please enter two numbers:\"); scanf(\"%d,%d\",&amp;a,&amp;b); p1=&amp;a; p2=&amp;b; if(a&gt;b) &#123; // *p1和*p2实际就是表示指针变量p1和 p2指向的变量（即a 和 b） temp=*p1; *p1=*p2; *p2=temp; &#125; printf(\"%d %d\",a,b); return 0;&#125; 方法三： 使用函数处理，将指向两个整型变量的指针变量作为实参传递给swap函数的形参指针变量，在函数中通过指针变量实现交换两个变量的值。 注： （1）在函数调用时，将实参变量的值传递给形参变量，采取的依然是单向传送的“值传递”方式。（实参—&gt;形参） （2）不能企图通过改变指针形参的值而改变指针实参的值。因为 C语言中实参变量和形参变量之间的数据传递是单向的”值传递”方式。用指针变量作为函数参数依然要遵循这一规则。 （3）不可能通过执行调用函数来改变实参指针变量的值，但是可以改变实参指针变量所指向变量的值 （1）下面这段代码就是试图通过实参变量的值传入形参变量，然后再改变形参变量的值，然后又传回到实参变量。这显然是无法实现的12345678910111213141516171819202122int main()&#123; void swap(int *p1,int *p2); int *pointer_1,*pointer_2,a,b; printf(\"Please enter two numbers:\"); scanf(\"%d,%d\",&amp;a,&amp;b); pointer_1=&amp;a; pointer_2=&amp;b; if(a&gt;b) &#123; swap(pointer_1,pointer_2); &#125; printf(\"%d %d\",*pointer_1,*pointer_2); return 0;&#125; void swap(int *p1,int *p2)&#123; //交换形参指针变量的值 int *temp; temp=p1; p1=p2; p2=temp;&#125; 结果并不能实现a和b的值交换，因为改变形参指针变量p1和p2的值并不能改变实参指针变量pointer_1和pointer_2的值。（2）通过执行调用函数来改变实参指针变量所指向变量的值。（可以实现两个输入的整数按从小到大的顺序输出）123456789101112131415161718192021222324/*方法三：通过执行调用函数来改变实参指针变量所指向变量的值，从而实现a和b的值交换*/ int main()&#123; void swap(int *p1,int *p2); int *pointer_1,*pointer_2,a,b; printf(\"Please enter two numbers:\"); scanf(\"%d,%d\",&amp;a,&amp;b); pointer_1=&amp;a; pointer_2=&amp;b; if(a&gt;b) &#123; swap(pointer_1,pointer_2); &#125; printf(\"%d %d\",*pointer_1,*pointer_2);//通过执行调用函数可以实现改变实参指针变量所指向变量的值。 // printf(\"%d %d\",a,b); //两种输出效果一样，因为*pointer_1和a是一个意思 return 0;&#125; void swap(int *p1,int *p2)&#123; int temp; temp=*p1; *p1=*p2; *p2=temp;&#125; 注：函数的调用可以（且只可以）得到一个返回值（即函数值），而使用指针变量作参数，可以得到多个变化了的值。 拓展：输入3个整数a,b,c, 要求按照从小到大的顺序将它们输出，用函数实现。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* 输入3个整数a,b,c,要求按照从小到大的顺序输出，利用函数的形式 */int main() &#123; void exchange(int *p1,int *p2,int *p3); int *pointer_1,*pointer_2,*pointer_3,a,b,c; printf(\"Please enter three numbers:\"); scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); pointer_1=&amp;a; pointer_2=&amp;b; pointer_3=&amp;c; printf(\"%d\\n\",pointer_1); exchange(pointer_1,pointer_2,pointer_3); //注意：exchange函数中的参数都是指针变量 printf(\"%d %d %d\\n\",*pointer_1,*pointer_2,*pointer_3); printf(\"%d\\n\",pointer_1); //可以发现实参指针变量在执行完调用函数后依然没有改变 return 0;&#125;void exchange(int *p1,int *p2,int *p3)&#123; void swap(int *p_1,int *p_2); if(*p1&gt;*p2) swap(p1,p2); //swap函数中的参数是指针变量，但其中交换的是指针变量指向的变量的值 if(*p2&gt;*p3) swap(p2,p3); if(*p1&gt;*p3) swap(p1,p3);&#125;void swap(int *p_1,int *p_2)&#123; int temp; temp=*p_1; *p_1=*p_2; *p_2=temp;&#125; 注意：main函数中的3个实参指针变量的值在执行完调用函数并未改变，这就正好说明前面所说的“执行完调用函数，并不能改变实参指针变量的值，但是可以改变实参指针变量指向的变量的值” 2. 如何遍历数组中的全部元素引用一个数组元素主要有以下两种方法： （1）下标法：如 a[i]; （2）指针法： 格 式 具体说明 *(a+i) a是数组名，通过数组名和元素序号计算元素地址，从而找到该元素 *(p+i) p是指向数组元素的指针变量，其初值为p=a 注： (1)其实上面两者与a[i]是等价的; (2)*(a+i)即使按数组首元素的地址加上相对位移量得到要找的元素的地址，然后找出该地址的内容。 相对位移量=i * 基本类型的字节长度；（如int类型一般就是4个字节，而char型一般就是1个字节） 输出一个拥有10个元素的整形数组的全部元素。 方法 一：利用数组下标的方式访问数组元素1234567891011121314int main() &#123; int a[10]; int i,j,length; length=sizeof(a)/sizeof(int); //求出数组的长度 for(i=0;i&lt;length;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; for(j=0;j&lt;length;j++) &#123; printf(\"%d\\n\",a[j]); &#125; return 0;&#125; 方法二：通过计算数组名计算数组元素地址，从而找出元素的值。123456789101112131415int main()&#123; int a[10]; int i,length; length=sizeof(a)/sizeof(int); for(i=0;i&lt;length;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; for(i=0;i&lt;length;i++) &#123; printf(\"%d\\t\",*(a+i)); //通过数组名和元素序号计算元素地址，再找到该元素。 &#125; return 0; &#125; 方法三：利用指针变量指向数组元素的方式访问数组元素 （这样不必每次都重新计算地址）12345678910111213141516int main()&#123; int a[10]; int *p; //p=a; //与p=&amp;a[0]等价 for(p=a;p&lt;(a+10);p++) &#123; scanf(\"%d\",p); &#125; for(p=a;p&lt;(a+10);p++) &#123; printf(\"%d\\t\",*p); &#125; return 0; &#125; 注意一个易错点：1234567891011121314151617int main()&#123; int a[10]; int i,length,*p; length=sizeof(a)/sizeof(int); p=a; for(i=0;i&lt;length;i++) &#123; scanf(\"%d\",p++); &#125; p=a; //注意：这里一定要重新将 &amp;a[0]的初始值赋给p,不然此时的p在下一个for循环的初始值就为 &amp;a[10]了。 for(i=0;i&lt;length;i++,p++) &#123; printf(\"%d\\t\",*p); //通过数组名和元素序号计算元素地址，再找到该元素。 &#125; return 0; &#125; 上面的第二个for循环也可以稍作修改，效果完全一样12345for(i=0;i&lt;length;i++) //注意修改的部分 &#123; printf(\"%d\\t\",*p++); //通过数组名和元素序号计算元素地址，再找到该元素。 &#125;return 0; 3. 通过指针引用数组元素的一些注意事项（1） 指向数组的指针变量也可以带下标，如p[i],.因为在程序编译时，对下标的处理方法是转换为地址的，对p[i]处理成*(p+i),因此如果p是指向一个整型数组元素a[0]，则p[i]代表a[i]. （2） *p++ （注意理解）由于++和*同优先级，且结合方向为自右向左，因此它等价于*(p++)。先引用p的值，实现*p的运算，然后再使p自增1。1234*p++相当于*(p++),也就是下面两步的组合：第一步：*p第二步：p++//先取*p,再使p值加1； 1234*(++p)则是下面两步的组合：第一步：p++第二步：*p//先使p值加1，再取*p； 1++(*p)则表示p所指向的元素值加1，如果p=a,则++(*p)相当于++a[0]. （3）如果p当前指向a数组中第i个元素a[i],则下列表达形式一一对应： 第一种表达方式 对应的第二种表达方式 *(p- -) a[i++] *(++p) a[++i] *(- -p) a[- -i] 4. 用数组名作函数参数和用变量名作函数参数(1)当用数组名作函数参数时，如果形参数组中各元素的值发生变化，则实参数组元素的值也随之发生变化。（常使用这种方法改变实参数组的值）实参数组名代表数组首元素的地址，而形参是用来接收来自实参传递过来的数组首元素地址的。因此，形参应该是一个指针变量（只有指针变量才能存放地址）。实际上，C编译都是将形参数组名作为指针变量来处理的。 例：函数fun的参数写成数组形式12fun(int arr[],int n) //arr为形参数组名 但程序在编译时是将形参数组名arr按指针变量处理的，相当于将fun的首部写成1fun(int *arr,int n) 这两种写法完全等价。 （2） 以变量名和数组名作为函数参数的比较 实参类型 变量名 数组名 要求形参的类型 变量名 数组名或指针变量 传递的信息 变量的值 实参数组首元素的地址 通过函数调用能否改变实参的值 不能实参变量的值 能改变实参数组的值 注：实参数组名代表一个固定的地址，或者说是指针常量，但形参数组名并不是一个固定的地址，而是按指针变量处理。（3） 用数组名作函数参数12345678910111213141516171819202122232425262728293031323334353637/*将数组a中n个整数按相反顺序存放。 (两头的元素相互交换)*/int main() &#123; void inv(int *arr,int n); int a[10]=&#123;1,5,6,9,7,8,3,2,0,4&#125;; int i,length; length=sizeof(a)/sizeof(int); printf(\"The original order is:\\n\"); for(i=0;i&lt;length;i++) &#123; printf(\"%d\\t\",a[i]); &#125; inv(a,length);//两头交换顺序 printf(\"\\n\"); printf(\"The new order is:\\n\"); for(i=0;i&lt;length;i++) &#123; printf(\"%d\\t\",a[i]); &#125; return 0;&#125;void inv(int arr[],int n) //写成int *arr也可以 &#123; int i=0,j,temp; int flag=n/2; while(i&lt;flag) &#123; j=n-i-1; temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; i++; &#125; return; &#125; （4） 用指针变量作函数参数123456789101112131415161718192021222324252627282930313233343536int main()&#123; void inv(int *arr,int n); int a[10]=&#123;1,5,6,9,7,8,3,2,0,4&#125;; int i,length; length=sizeof(a)/sizeof(int); printf(\"The original order is:\\n\"); for(i=0;i&lt;length;i++) &#123; printf(\"%d\\t\",a[i]); &#125; inv(a,length);//两头交换顺序 printf(\"\\n\"); printf(\"The new order is:\\n\"); for(i=0;i&lt;length;i++) &#123; printf(\"%d\\t\",a[i]); &#125; return 0;&#125;//改进之后void inv(int *arr,int n)&#123; int *i,*j,*p,temp; int flag=n/2; i=arr; j=arr+n-1; p=arr+flag; for(;i&lt;p;i++,j--) &#123; temp=*i; *i=*j; *j=temp; &#125; return; &#125; （5） 如果用指针变量作实参，必须先使指针变量有一个确定值，指向一个已定义的对象。如下面是不正确的：1234567891011121314int main()&#123; void f(int *x,int n); int *p;//指针变量未指向数组元素（或者说一个已定义的对象）。 ... f(p,10); ...&#125;void f(int *x,int n)&#123; ... return;&#125; 编译时出错，原因是指针变量p没有确定值，谈不上指向哪个变量。 5. 使用指针引用多维数组（1） 二维数组a的有关指针 表示形式 含义 地址 a 二维数组名，指向一维数组a[0],即0行首地址 2000 a[0],*(a+0),*a 0行0列元素地址 2000 a+1,&amp;a[1] 1行首地址 2016 a[1],*(a+1) 1行0列的地址，即&amp;a[1][0] 2016 a[1]+2,*(a+1)+2,&amp;a[1][2] 1行2列元素地址,即&amp;a[1][2] 2024 *(a[1]+2),*(*(a+1)+2),a[1][2] 1行2列元素的值，即a[1][2] 元素值为13 注：(1) 二维数组a的定义如下：1int a[3][4]=&#123;&#123;1,3,5,7&#125;,&#123;9,11,13,15&#125;,&#123;17,19,21,23&#125;&#125; 且假设二维数组a的首行的首地址为2000. (2) C语言规定了数组名代表数组首元素的地址。所以a为二维数组名，指向一维数组a[0]（二维数组的首元素），即0行首地址；a[0]为一维数组名，指向一维数组的首元素即a[0][0]，即0行0列元素地址； (3) a+1是二维数组a中序号为1的行的首地址（序号从0算起），即1行首地址，因为a是二维数组名，指向一维数组a[0]，表示0行首地址。千万不要和a[0]+1搞混, a[0]+1表示0行1列元素的地址。 (4) *(a+1)表示1行0列元素地址，即&amp;a[1][0]，和a[1]等价。 (5) 二维数组名（如a）是指向行的。因此a+1中的‘1’代表一行中全部元素所占的字节数（一行有4个整形元素，所以占16个字节）。一维数组名（如a[0],a[1]）是指向列元素的。因此a[0]+1中的‘1’代表一个元素所占的字节数（一个整形元素，所以占4个字节）。 (6) 在指向行的指针前面加一个*号，就转换为指向列的指针。 (7) 在指向列的指针前面加一个&amp;号，就转换为指向行的指针。 (8) a[0]指向0行0列元素的指针，&amp;a[0]则指向二维数组的0行，与a等价。因为a[0]与*(a+0)等价，因此&amp;a[0]与&amp;*a等价，也就是与a等价，它指向二维数组的0行。 (9) &amp;a[i]和a[i]的值虽然一样，但它们的含义不一样。&amp;a[i]或a+i指向行，而a[i]或*(a+i)指向列。 6. 指向多维数组元素的指针变量(1)指向数组元素的指针变量12345678910111213141516171819202122/*指向多维数组元素的指针变量 (1)指向数组元素的指针变量 *///用指向元素的指针变量输出二维数组各元素的值。 int main() &#123; int a[3][4]=&#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int *p; for(p=a[0];p&lt;a[0]+12;p++) //注意：p是指向整形元素的，如这里p初始指向a[0][0]; &#123; if((p-a[0])%4==0) //p移动4次后换行 &#123; printf(\"\\n\"); &#125; //(1) %4d表示输出的整形数据宽度为4位，且右对齐，如果整形数据不够4位则前面补空格; //(2) 如果要左对齐，则在%后加\"-\"号即可，如\"%-4d\" ; printf(\"%-4d\",*p); &#125; return 0;&#125; (2)指向由m个元素组成的一维数组的指针变量12345678910111213/*指向m个元素组成的一维数组的指针变量 */int main()&#123; int a[3][4]=&#123;1,3,5,7,9,11,13,15,17,19,21,23&#125;; int (*p)[4],i,j; p=a; // p的值是一维数组a[0]的起始地址; printf(\"Please enter row and column:\\t\"); scanf(\"%d,%d\",&amp;i,&amp;j); printf(\"a[%d,%d]=%d\\n\",i,j,*(*(p+i)+j)); return 0; &#125; 注： （1）int (*p)[4]表示定义p为一个指针变量，它指向包含4个整形元素的一维数组. （2）*p两侧的括号不可以缺少， 若写成*p[4]则表示指针数组。（因为方括号[ ]的运算优先级别高） （3） 格式 含义 int a[4] a有4个元素，每个元素都是整型 int (*p)[4] *p有4个元素，每个元素为整型。也即p所指的对象是有4个整型元素的数组，即p是指向一维数组的指针。 （4）int (*p)[4]中的p的类型不是int *类型，而是int (*)[4]型，p被定义为指向一维整形数组的指针变量，一维数组有4个元素，因此p的基类型为一维数组，其长度是16字节。 （3） 一个需要注意的地方123456789int main()&#123; int a[4]=&#123;1,3,5,7&#125;; //这里是一维数组 int (*p)[4]; //不能写成 p=a,因为这样写表示p的值是&amp;a[0],指向a[0],一维数组名表示首元素的地址; p=&amp;a; //表示p指向一维数组（行） printf(\"%d\\n\",(*p)[2]);//表示访问p所指向一维数组（行）中的序号为2的元素; return 0;&#125; 7. 引用一个字符串的方法(1) 用字符数组存放一个字符串，可以通过数组名和下标引用字符串中一个字符，也可通过数组名和格式声明”%s”输出该字符串。123char string[]=\"I love China!\";printf(\"%s\\n\",string);//用%s格式声明输出string,可以输出整个字符串。printf(\"%c\\n\",string[3]);//使用%c格式输出一个字符数组元素。 (2)用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。123//指针变量string指向字符串的第1个字符char *string=\"I love China!\";//定义指针变量并初始化。printf(\"%s\\n\",string); 注： （1）C语言中只有字符变量，没有字符串变量。 （2）这两者是等价的1char *string=\"I am a student\"; 12char *string;string=\"I am a student\"; 上述语句都是将字符串的第一个字符的地址赋给指针变量string，此后string就指向“I am a student”.当然也可以对string重新赋值，从而改变string的指向。 （3）%s是输出字符串时所用的格式符，在输出项中给出字符指针变量名string，则系统会输出string所指向的第一个字符，然后自动使string加1，使之指向下一个字符，再输出该字符……如此直到遇到字符串结束标志’\\0’为止。 8.复制一个字符数组到另外一个字符数组（字符串间的复制）—— 一种效果的多种实现方式12345678910111213141516171819int main()&#123; void copy_string(char *a,char *b); char a[]=\"I am a teacher.\"; char b[]=\"You are a student.\"; int i; printf(\"String a is: %s\\n\",a); printf(\"String b is: %s\\n\",b); printf(\"copy string a to string b:\\n\"); copy_string(a,b); printf(\"String a is: %s\\n\",a); printf(\"String b is: %s\\n\",b); return 0;&#125; void copy_string(char *a,char *b)&#123; for(;*b++=*a++;); &#125; 上述copy_string函数中可以有多种不同方式而实现相同的效果。 (1)12345678910111213while(*a!='\\0')&#123; *b++=*a++;&#125;*b='\\0';``` **(2)**```Cwhile((*b=*a)!='\\0')&#123; b++; a++;&#125; (3)1while((*b++=*a++)!='\\0'); (4)12//注意\"\\0\"的ASCII码为0; while((*b++=*a++)!=0);//千万不要忘了加\";\" 也可以写成1234567 while(*b++=*a++);``` **注：** 不等于0也就是表示为真, 这里表示先把\\*a的值赋值给\\*b,再判断\\*b是否为0（'\\0'的ASCII值为0），为0则跳出while循环，否则继续将a数组中的未复制的字符复制到b数组中去。**(5)**```Cfor(;*b++=*a++;); 或1for(;(*b++=*a++)!=0;); 9. 用字符指针作为函数参数时，实参与形参的类型的对应关系有如下几种： 实参 形参 字符数组名 字符数组名 字符数组名 字符指针变量 字符指针变量 字符指针变量 字符指针变量 字符数组名 10. 字符指针变量和字符数组的比较（七个小点）（1） 字符数组由若干个元素组成，每个元素中放一个字符。而字符指针变量中存放的是地址（字符串中第一个字符的地址）。 （2）赋值方式: 可以对字符指针变量赋值，但不能对数组名赋值。12char *a;//定义a为字符指针变量a=\"I love China!\";//将字符串首元素的地址赋给指针变量。合法。 123char str[14];str[0]='I';//对字符数组元素赋值，合法。str=\"I love China!\";//数组名是地址，是常量，不能被赋值，非法。 （3） 初始化 字符指针变量的赋值1char *a=\"I love China!\";//定义并赋值。 等价于12char *a;//先定义a=\"I love China!\"; //再赋值 数组的初始化1char str[14]=\"I love China!\";//定义字符数组str，并把字符串赋给数组中各元素。合法。 不等价于（下面这种字符数组的初始化是非法的）12char str[14];str[]=\"I love China!\";//企图把字符串赋给数组中各元素。错误。 注： 数组可以在定义时对各元素赋初值，但不能用赋值语句对字符数组中全部元素整体赋值。 （4）存储单元的内容。编译时字符数组分配若干存储单元，以存放各元素的值；而对字符指针变量，只分配一个存储单元（Visual C++为指针变量分配4个字节）。 （5）如果定义了字符数组，但未对它赋值，这时数组中的元素的值是不可预料的。可以引用（如输出）这些值，结果显然是无意义的，但不会造成严重的后果，容易发现和改正。 如果定义字符指针变量，应当及时把一个字符变量（或字符数组元素）的地址赋值给它，使它指向一个字符型数据，如果未对它赋予一个地址值，它并未具体指向一个确定的对象。此时如果向该指针变量所指向的对象输入数据，可能会造成严重的后果。（定义了字符指针变量应及时赋值）12char *a;//定义字符指针变量ascanf(\"%s\",a);//企图从键盘输入一个字符串，使a指向该字符串。错误。 注意： 此时a的值是不可预料的，它可能指向内存中空白的（未用的）用户存储区（好的情况），也有可能指向内存中已存储指令或数据的有用内存段，这就会破坏程序或有用数据，甚至破坏了系统，会造成严重的结果。因此在定义指针变量后，及时指定其指向，如：123char *a,str[10];a=str;//使a指向str数组的首元素scanf(\"%s\",a);//从键盘输入一个字符串存放到a所指向的一段存储单元中。正确。 （5） 指针变量的值是可改变的；而数组名代表一个固定的值（数组元素的地址），是不可改变的。 改变指针变量的值123char *a=\"I love China!\";a=a+7;//改变指针变量的值，使a指向字符串中的第7个字符。printf(\"%s\",a);//输出的结果为“China！” 下面是错误的123char str[]=&#123;\"I love China!\"&#125;;str=str+7;//错误printf(\"%s\",str); （6） 字符数组中各元素的值是可以改变的（可以对它们再赋值）；但字符指针变量指向的字符串常量中的内容是不可以被取代的（不能对它们再赋值）。1234char a[]=\"House\";char *b=\"House\";a[2]='r';//合法，r取代a数组元素a[2]的原值u.b[2]='r';//非法。字符串常量不能改变。 （7） 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。123char *format;format=\"a=%d,b=%f\\n\";//使format指向一个字符串。printf(format,a,b);//这种printf函数称为可变格式输出函数。 11.用函数指针变量调用函数1234567891011121314151617181920212223242526272829//方法一：通过函数名调用函数 //略......//方法二：通过函数指针变量调用函数 int main()&#123; int max(int x,int y); int a,b,c; //定义p是一个指向函数的指针变量，它可指向函数的类型为整型且有两个整型参数的函数。 int (*p)(int x,int y); //p的类型用int(*)(int,int)表示。 printf(\"Please enter a and b:\"); scanf(\"%d,%d\",&amp;a,&amp;b); //可通过改变p的指向,并结合if...else...或switch...case...,从而根据不同情况调用不同的函数。 p=max;//使p指向max函数，函数名代表函数入口地址。 c=(*p)(a,b);//通过指针变量调用max函数。 printf(\"a=%d\\nb=%d\\nmax=%d\\n\",a,b,c); return 0;&#125;int max(int x,int y)&#123; int max; if(x&gt;y) max=x; else max=y; return max;&#125; 注： （1）*p的括号不能省去，这表示p先与*号结合，是指针变量，然后再与后面的()结合，()表示函数，即该指针变量不是指向一般的变量,而是指向函数,最前面的int表示函数值（函数返回值为整型）。1int (*p)(int,int);//p是指向函数的指针。 （2）1int *p(int,int);//p是一个返回int*型指针的函数。 由于（）优先级高于*号，它相当于1int *(p(int,int)); 就变成了声明一个p 函数(这个函数的返回值是指向整型变量的指针)。 （3）用函数名调用函数，只能调用一个指定的函数；而通过指针变量调用函数比较灵活，可根据不同情况调用不同的函数。因为可以改变指针变量的值从而使其指向不同的函数。 12. 指向m个元素组成的一维数组的指针变量与指向数组元素的指针变量（难点）（1）1int *p; p是指向整形数据的，p+1所指向的元素是p所指向的列元素的下一元素（按在内存中的存储的下一个整型元素）。（2）1int (*p)[4]; p是指向一个包含4个元素的一维数组。如果这时p指向a[0]（即p=&amp;a[0]）,则p+1不是指向a[0][1]，而是指向a[1]（第一行的首地址，是指向行），p的值以一维数组的长度为单位。所以“p+1”是加上一个一维数组的长度。 13. 指针数组和多重指针（1）指针数组：一个其数组元素均为指针型数据的数组。即指针数组中每一个元素都存放一个地址，相当于一个指针变量。如定义一个指针数组：1int *p[4]; 由于[ ]比*优先级高，所以p先与[4]结合，形成p[4]形式，这显然是数组形式，。然后再与p前面的 * 结合，*表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都可指向一个整型变量。注意不要写成1int (*p)[4];//这是指向一维数组的指针变量。 （2） 要用到指针数组的情况：指针数组比较适合用来指向若干字符串（各字符串的长短不一）。 a. 按一般方法，字符串本身就是一个字符数组。因此要设计一个二维的字符数组才能存放多个字符串，但定义二维数组时要指定列数，也就是二维数组中每一行包含的元素个数（即列数）相等。而实际各字符串（如书名）的长短一般是不一样的。如按最长的字符串来定义列数，则会浪费许多内存单元。 b. 使用指针数组的方法则可以很灵活地对字符串进行处理：可分别定义一些字符串，然后用指针数组中的元素分别指向各字符串。如：name[0]中存放字符串”Follow me”的首字符的地址，name[1]中则存放字符串”BASIC”的首字符的地址……如果想对字符串排序，只须改变指针数组中各元素的指向（即改变各元素的值，这些值是各字符串的首地址）。（3）定义指针数组，并赋初值。如：12//定义指针数组name，它有5个元素，其初值分别为 \"Python\",\"Java\",\"C#\",\".NET\",\"JavaScript\"的首字符的地址。 char *name[]=&#123;\"Python\",\"Java\",\"C#\",\".NET\",\"JavaScript\"&#125;; （4）字符比较函数strcmp使用时一个需注意的地方123456注意：(1) strcmp(str1,str2),所以应分别传入的是两个字符串的首字符的地址。如：strcmp(\"Hello\",\"World\"),其中实质分别传入的是\"Hello\"、\"World\"这两个字符串的首字符的地址。(2) 其原型为extern int strcmp(char *s1,char *s2); (3) 使用字符串处理函数时，应在程序头文件上加上 \"#include &lt;string.h&gt;\" （5）指向指针数据的指针1char **p; 相当于1char *(*p); 可把它分为两个部分来看：1char * 和 (*p) 前面的char *表示p指向的是char *型的数据，也就是说p指向一个字符指针变量（这个字符指针变量指向一个字符型数据）。如果引用*p，就得到p所指向的字符指针变量的值。如：1234char *name[]=&#123;\"Python\",\"Java\",\"C#\",\".NET\",\"JavaScript\"&#125;;p=name+2;printf(\"%d\\n\",*p);//输出name[2]的值（一个地址）printf(\"%s\\n\",*p);//输出字符串“C#” （6）小结利用指针变量访问另一个变量就是”间接访问“。如果在一个指针变量中存放一个目标变量的地址，这就是“单级间址”；指向指针数据的指针用的则是”二级间址“。从理论上说，间址方法可以延伸到更多的即，即多重指针，即多级间接访问。 14. 内存的动态分配(1) 全局变量是分配在内存中的静态存储区的；非静态的局部变量（包括形参）是分配在内存中的动态存储区的，这个存储区是一个称为栈(Stack)的区域。 (2) 此外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明中定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据临时存放在一个特别的自由存储区，称为堆区。 可以根据需要，向系统申请所需大小的空间。由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。 15. 建立内存的动态分配对内存的动态分配是通过系统提供的库函数来实现的，主要有malloc，calloc，free，realloc这4个函数。以上四个函数的声明在stdlib.h头文件中，在用到这些函数时，应当用”#include “指令。（1）malloc函数其函数原型是1void *malloc(unsigned int size); 其作用是在内存的动态存储区中分配一个长度为size的连续空间。形参size的类型定为无符号整型（不允许为负数）。此函数的值（即“返回值”）是所分配区域的第一个字节的地址，或者说此函数是一个指针函数，返回的地址指向该分配区域的开头位置。如：1malloc(100);//开辟100字节的临时分配区域，函数值为其第1个字节的地址。 注意：指针的基类型为void，即不指向任何类型的数据，只提供一个地址。（2）calloc函数其函数原型为：1void *calloc(unsigned int n,unsigned int size); 其作用是在内存的动态存储区中分配n个长度为size的连续存储空间，这个空间一般比较大，足以保存一个数组。 用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size。这就是 动态数组。函数返回指向所分配的起始位置的指针；如果分配不成功，返回NULL。如：1p=callol(50,4);//开辟50*4个字节的临时分配域，把起始地址赋给指针变量p。 （3）free函数其函数原型为：1void free(void *p); 其作用是释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用calloc或malloc函数时得到的函数返回值。如：1free(p);//释放指针变量p所指向的已分配的动态空间。free函数无返回值。 （4）realloc函数其函数原型为：1void *realloc(void *p,unsigned int size); 若已通过malloc或calloc函数获得了动态空间，可用realloc函数对动态空间大小进行重新分配。 （5）一个值得注意的点以前的C版本提供的malloc和calloc函数得到的是指向字符型数据的指针，其原型为：1char *malloc(unsigned int size);//返回字符型数据的指针 因此若开辟的空间用来存放整数，则要进行类型转换，如：12int *pt;pt=(int *)malloc(100);//将指向字符数据的指针转换为指向整型数据的指针。 注意： （1）类型转换只是产生了一个临时的中间值赋给了pt，但没有改变malloc函数本身的类型。 （2）C99标准把malloc，calloc，realloc函数的基类型定为void类型，这种指针称为无类型指针，即不指向哪一种具体的类型数据，只表示用来指向一个抽象的类型的数据，即仅提供一个纯地址，而不能指向任何具体的对象。 16. void指针类型可以定义一个基类型为void的指针变量（即void *型变量），它不指向任何类型的数据。 请注意： （1）不要把”指向void类型“理解为能指向”任何的类型“的数据，而应该理解成“指向空类型”或“不指向确定的类型”的数据。 （2）在将void指针的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。 17. 指针的优点(1) 提高程序效率； (2) 在调用函数时当指针指向的变量的值改变时，这些值能够为主调函数使用，即可以从函数调用得到多个可改变的值； (3) 可以实现动态存储分配。 18. 宏定义（易错点）宏定义：用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。 注意： （1）宏名在宏展开时被直接替换为宏定义时宏名后面的字符串。 （2）字符串中可以含任何字符，可以是常数，也可以是表达式。 （3）宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。123456789101112131415#define N 2#define M N+1#define NUM 2*M+1 //这时候NUM=2*N+1+1=6，即用N+1直接替换Mint main()&#123; int i; printf(\"N=%d\\n\",N); printf(\"M=%d\\n\",M); printf(\"NUM=%d\\n\",NUM); for(i=1;i&lt;=NUM;i++) printf(\"%d\\n\",i); return 0;&#125; 宏定义是由源程序中的宏定义命令#define完成的，宏代换是由预处理程序完成的。 宏定义的一般形式为：1#define 宏名 字符串 表示这是一条预处理命令，所有的预处理命令都以#开头。define是预处理命令。宏名是标识符的一种，命名规则和标识符相同。字符串可以是常数、表达式等。这里所说的字符串是一般意义上的字符序列，不要和C语言中的字符串等同，它不需要双引号。 19. 定义结构体 （1） 先声明结构体类型，再定义该类型的变量。1234567891011struct Student&#123; int num; char name[20]; char sex; int age; float score; char addr[30];&#125;;//struct Student为结构体类型名，student1，student2是结构体变量名。struct Student student1,student2; （2） 在声明类型的同时定义变量123456789struct Student&#123; int num; char name[20]; char sex; int age; float score; char addr[30];&#125; student1,student2; （3）不指定类型名而直接定义结构体类型变量123456789struct&#123; int num; char name[20]; char sex; int age; float score; char addr[30];&#125; student1,student2; (4) 结构体的初始化需注意的一个地方 123456789101112struct Data&#123; int i; char ch; float f;&#125; a;//a.i = 65;//错误，“a.d = 65;”是一个可执行代码，需放在函数中才能执行。int main()&#123; a.i = 65;//正确 return 0;&#125; 12345678910111213141516171819202122232425262728struct Data&#123; int i; char ch; float f;&#125;;struct Data c;//错误的,为可执行代码，应放在函数中struct Data a = &#123;65,'H',30.0&#125;;//正确struct Data b = &#123;.i= 0, .ch = 'H',.f = 30.0&#125;;//正确int main()&#123; //不能使用赋值语句对结构体变量中的全部成员整体赋值。(字符数组也是这个道理) /* struct Data d; d=&#123;86,'K',63.0&#125;;//错误 */ struct Data d=&#123;86,'K',63.0&#125;; return 0;&#125;/*struct Data a;a.i= 0; is not a simple initializer, it is executable code; it cannot occur outside of a function. Use a proper initializer for a.struct Data a = &#123;65,'H',30.0&#125;;or with named initializer syntax (not available in all compilers, and as yet only in C):struct Data a = &#123;.i= 0, .ch = 'H',.f = 30.0&#125;;*/ 20. 结构体指针（1） 指向结构体对象的指针变量既可以指向结构体变量，也可以指向结构体数组中的元素。 （2） 3种访问结构体变量的成员的方法： 如果p指向一个结构体变量stu，下列三种用法等价：1231. stu.成员名 （如stu.name）2. (*p).成员名 (如(*p).name)3. p-&gt;成员名 (如p-&gt;name) （3）用结构体变量和结构体变量的指针作函数参数 a. 用结构体变量的成员作实参；如用stu[1].name作实参，将实参值传给形参。 b. 用结构体变量作实参；注意：在函数调用期间形参也要占用内存单元，空间和时间开销较大。 c. 用指向结构体变量（或数组元素）的指针作实参，将结构体变量（或数组元素）的地址传给形参； 21. 用指针处理链表(1) 静态链表 (2) 动态链表 22. 共用体类型(1) 几个不同类型的变量共享同一段内存的结构，称为“共用体”类型的结构。 (2) 结构体和共用体的区别结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员所占的内存长度，每个成员存储的起始地址是相同的。 23. 共用体数据类型的特点(1) 同一个内存段可以用来存放几种不同数据类型的成员，但在每一瞬间只能存放其中一个成员，而不是同时存放几个。即每一瞬间，共用体变量中只能存放一个值。123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;union Data&#123; int i; char ch; float f;&#125;;//a.i=65;//错误的//union Data a = &#123;65,'H',30.0&#125;;//注意：不能同时初始化共同体的3个成员，因为它们占用同一段存储单元。 int main()&#123; a.i=65;//注意赋值不能在函数外 ,因为\"a.i=65\"是一段可执行的代码，必须放在函数中才能执行。 printf(\"%d\\n\",a.i);//输出整数65 printf(\"%c\\n\",a.ch);//输出字符‘a’ printf(\"%f\\n\",a.f);//输出实数0.000000（难点） return 0;&#125; (2) 共用体初始化表中只能有一个常量。 123456789union Data&#123; int i; char ch; float f;&#125; a=&#123;1,'a',2.5&#125;;//错误，不能同时初始化3个成员，因为它们占用同一段存储单元。union Data b=&#123;2,'b','1.5'&#125;;//也是错误，理由同上。union Data c=&#123;16&#125;;//正确，对第一个成员初始化union Data d=&#123;.ch='h'&#125;;//正确，C99允许对指定的一个成员初始化。 (3) 共用体变量中其作用的成员是最后一次被赋值的成员(前面的赋值会被后面的赋值所覆盖)。 123a.ch='a';a.f=2.5;a.i=66; 在完成上述3个赋值运算后，变量存储单元存放的是最后存入的40，原来的’a’和1.5都被覆盖了。如果此时用1printf(\"%c\",a.ch);//输出的是字符'b'（因为ASCII码为66，正好为字符'b'） (4) 共用体变量的地址和它的各成员的地址都是同一地址（起始地址相同）。 (5) C99允许同类型的共用体变量相互赋值。如：1b=a;//a和b是同类型的共用体变量，合法 (6) 以前的的C规定不能用共用体变量作为函数参数，但可以使用指向共用体变量的指针作函数参数。C99允许用共用体变量作为函数参数。 (7) 共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员。 24. 枚举类型如果一个变量只有几种可能的值，则可以定义为枚举类型。所谓枚举就是把可能的值一一列举出来，变量的值只限于列举出来的值的范围内。 (1) C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符（有名字）而把它们看作变量，不能对它们赋值。123enum Weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;;sun=7;//错误，不能对枚举元素赋值。mon=1;//错误，不能对枚举元素赋值。 (2) 每一个枚举元素都代表一个整数，C语言编译按定义时的顺序默认为它们的值为0,1,2,3,4,5…。如：1enum Weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; 这里默认sun的值为0，mon的值为1，…sat的值为6。如果有赋值语句：1workday=mon; 相当于1workday=1; 也可以人为地指定枚举元素的数值，在定义枚举类型时显式地指定，例如：1enum Weekday&#123;sun=7,mon=1;tue,wed,thu,fri,sat&#125; workday,week_end; 指定枚举常量sun的值为7，mon为1，以后顺序加1，sat为6。 注： 由于枚举型变量的值是整数，因此C99把枚举类型也作为整型数据中的一种，即用户自行定义的整型类型。 (3) 枚举类型可以用来作判断比较。例如：12if(workday==mon)...if(workday&gt;sun)... 25. 用typedef声明新类型名(1) 简单地用一个新的类型名代替原有的类型名 12typedef int Integer;//指定用Integer为类型名，作用与int相同。typedef float Real;//指定Real为类型名，作用与float相同。 下面两行等价：12int i,j; float a,b;Integer i,j; Real a,b; (2) 命名一个简单的类型名代替一个复杂的类型表示方法。 a. 命名一个新的类型名代表结构体类型123456typedef struct&#123; int month; int day; int year;&#125; Date; 以上声明了一个新类型名Date，代表上面的一个结构体类型。12Date birthday;//定义结构体变量birthday，不要写成struct Date birthday；Date *p;//定义结构体指针变量p，指向此结构体类型数据。 b. 命名一个新的类型名代表数组类型12typedef int Num[100];//声明Num为整型数组类型名。Num a;//定义a为整型数组名，其包括100个元素。相当于int a[100]; c. 命名一个新的类型名代表指针类型12typedef char * String;//声明String为字符指针类型名String p,s[10];//定义p为字符指针变量，s为字符指针数组。 d. 命名一个新的类型名代表指向函数的指针类型12typedef int (*Pointer)();//声明Pointer为指向函数的指针类型名，该函数返回int类型的数值。Pointer p1,p2;//定义p1,p2为指向函数的指针变量。 注： 声明一个新的类型名的方法就是： 按定义变量的方式，把变量名换成新的类型名，并且在最前面加上一个typedef,就声明了新类型名代表原来的类型。 (3) typedef 与 #define表面上有相似之处,但是两者是不同的 1typedef int Count; 和1#define Count int 从表面上看，它们都是用Count代表int。但事实上，它们二者是有区别的。 a. #define 是在预编译时处理的，它只能作简单的字符串替换。12#define Count intCount a; 这里只是简单地用Count这个字符来代替int而已。 b. typedef是在编译阶段处理的，它并不是作简单的字符串替换。12typedef int Num[10];Num a; 并不是用“Num[10]”去代替“int”，而是如同定义变量的方法那样先生成一个类型名，然后再去定义变量。 (4) 当不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放到一个头文件中，然后在需要用到它们的文件中用#include 指令把它们包含在文件中。这样就不需要在各文件中自己定义typedef名称了。 (5) 使用typedef名称有利于程序的通用和移植。 例如有的计算机系统int类型数据占用两个字节（假设为A系统），有的系统则占用4个字节（假设为B系统）。如果把一个C程序从B系统移植到A系统中，按照一般方法则是要将定义变量中的每个int改为long，如果程序中有多处用int定义变量，则需要修改多处。（4个字节表示一个整数，其数值范围为-21亿到+21亿，要想它在2个字节表示一个整数的系统中存储下来，则必须提前将int类型改为long型（在2个字节表示一个整数的系统long型占4个字节，能够容纳下-21亿到+21亿的数））。（注意理解） 如果使用Integer来替代int，1typedef int Integer; 程序中所有整型变量都用Integer定义。在移植时只须修改typedef定义体一处即可:1typedef long Integer; 26. 文件（难点、抽象）1. 两种类型的文件 程序文件 源程序文件（.c） 目标文件（.obj） 可执行文件（.exe） 数据文件 按数据的组织类型分为 ASCII文件（文本文件）：每个字节放一个字符的ASCII代码 二进制文件（映像文件）：存储在内存的数据的映像 2. 数据在磁盘上如何存储字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以用二进制形式存储。 3. 文件指针一种C编译环境提供的stdio.h头文件中有以下的文件类型声明：123456789101112typedef struct&#123; short level;//缓冲区“满”或“空”的程度 unsigned flags;//文件状态标志 char fd;//文件描述符 unsigned char hold;//如缓冲区无内容不读取字符 short bsize;//缓冲区的大小 unsigned char * buffer;//数据缓冲区的位置 unsigned char * curp;//指针当前的指向 unsigned istemp;//临时文件指示器 short token;//用于有效性检查&#125; FILE; （1）不同的C编译系统的FILE类型包含的内容不完全相同，但大同小异。 （2）在程序中可以直接用FILE类型定义变量。 （3）每一个FILE类型变量对应一个文件的信息区，在其中存放该文件的有关信息。 （4）一般不对FILE类型变量命名，也就是不通过变量的名字来引用这些变量,而是设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。1FILE * fp;//定义一个指向文件类型数据的指针变量； （5）每一个指针变量指向一个FILE类型变量，每一个FILE类型变量对应一个文件的信息区。指向文件的指针变量是指向内存中的文件信息区的开头。 4. 打开和关闭文件（1）打开文件就是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）。1fopen(文件名,使用文件方式);//fopen函数的返回值是一个指向文件类型的指针变量。 例如：1fopen(\"f1\",\"r\"); 表示要打开名字为“f1”的文件，使用文件方式为“读入”，fopen函数的返回值是指向文件f1的指针（即f1文件信息区的起始地址）。 使用文件方式 文件使用方式 含义 如果指定的文件不存在 r（只读） 为了输入数据，打开一个已存在的文本文件 出错 w（只写） 为了输出数据，打开一个文本文件 建立新文件 a（追加） 向文本末尾添加数据 出错 rb（只读） 为了输入数据，打开一个二进制文件 出错 wb（只写） 为了输出数据，打开一个二进制文件 建立新文件 ab（追加） 在二进制文件末尾添加数据 出错 r+（读写） 为了读和写，打开一个文本文件 出错 w+（读写） 为了读和写，建立一个新的文本文件 建立新文件 a+（读写） 为了读和写，打开一个文本文件 出错 rb+（读写） 为了读和写，打开一个二进制文件 出错 wb+（读写） 为了读和写，建立一个新的二进制文件 建立新文件 ab+（读写） 为了读和写，打开一个二进制文件 出错 注： “w”(只写)：如果原来不存在该文件，则在打开文件前建立一个以指定的名字命名的文件。如果原来存在该文件，则先删除，然后重新建立一个新文件。 常用下面的方法打开一个文件：12345if((fp=fopen(\"file1\",\"r\"))==NULL)&#123; printf(\"cannot open this file\\n\"); exit(0);//关闭所有文件，终止正在执行的程序。&#125; （2）关闭文件就是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件。1fclose(文件指针); fclose函数的返回值为： 当成功执行了关闭操作，则返回值为0； 反之，返回值为EOF（-1）； 例如：1fclose(fp);//fp为指向文件的指针变量； 5. 向文件读写字符读写一个字符的函数 函数名 调用形式 功能 返回值 fgetc fgetc(fp) 从fp指向的文件读入一个字符 读成功，则返回所读的字符；失败则返回文件结束标志EOF（即-1） fputc fputc(ch,fp) 把字符ch写到fp指向的文件中 输入成功，则返回值是输出的字符；输出失败，则是返回EOF(即-1) 注: C系统已把fputc和fgetc函数定义为宏名putc和getc:12#define putc(ch,fp) fputc(ch,fp)#define getc(ch,fp) fgetc(ch,fp) 这是在stdio.h文件中定义的。因此，在程序中用putc和fputc作用是一样的，用getc和fgetc的作用也是一样的。 6. 向文件读写一个字符串读写一个字符串的函数 函数名 调用形式 功能 返回值 fgets fgets(str,n,fp) 从fp指向的文件中读入一个长度为（n-1）的字符串（不包括字符串结束字符‘\\0’） 读成功，返回地址str；失败则返回NULL fputs fputs(str,fp) 将str指向的字符串输出到fp指向的文件中 输出成功，返回0；否则返回非0值 注： 如果在读完n-1个字符之前遇到换行符‘\\n’或文件结束符EOF，读入即结束，但将所遇到的换行符‘\\n’也作为一个字符读入。 7.用格式化的方式读写文件12fprintf(文件指针,格式字符串，输出表列);//格式化写函数（写入文件）fscanf(文件指针，格式字符串，输入列表);//格式化读函数（读文件） 注： fprintf: 输出时要将内存中的二进制形式转化成字符。 fscanf: 读入时要将文件中的ASCII码转换为二进制形式，再保存在内存变量中。 上面两种转换要花费一定的时间，因此，在内存与磁盘频繁交换数据的情况下，最好不用fprintf和fscanf函数，而用下面介绍的fread和fwrite函数进行二进制的读写。 8.用二进制方式对文件进行读写1fread（buffer,size,count,fp);//执行成功时返回形参count的值（int），即读入数据项的个数； buffer：表示从文件中读入的数据要存入到内存中的存储块地址； size：要读写的字节数（每个数据项的大小）； count：要读写的数据项数；（每个数据项的长度为size） fp: FILE类型指针； 1fwrite(buffer,size,count,fp);//执行成功时返回形参count的值（int），即输出数据项的个数； buffer：要输出到文件中的那段数据在内存中的存储区的地址；","categories":[],"tags":[]},{"title":"Python笔记（一）","slug":"Python笔记（一）","date":"2018-01-31T16:40:18.694Z","updated":"2019-04-19T01:15:47.997Z","comments":true,"path":"2018/02/01/Python笔记（一）/","link":"","permalink":"https://yuanziwoxin.github.io/2018/02/01/Python笔记（一）/","excerpt":"这是python学习笔记(一)，仅供参考！","text":"这是python学习笔记(一)，仅供参考！ 1.元组与列表的区别及元组的一些小细节 12345678910type((1)) #这里显示为int类型，而不是tuple类型，这里把里面的“（）”即括号当作是数学运算中的括号type(('hello')) #这里显示为str类型，而不是tuple类型type([\"hello\",1,3,False]) #显示为list类型type((False,\"hello\",1,4)) #显示为tuple类型#注意：方括号为list类型，而圆括号为tuple类型type((1,)) #表示只有一个元素的元组type((\"hello\",)) #表示只有一个元素的元组type(()) #这里显示为tuple类型type([1]) #这里显示为list类型# str,list,tuple都为序列，其许多相应操作都类似 2. 集合 12345678910111213141516type(&#123;1,5,3,7&#125;)#\"&#123;&#125;\"表示集合，集合的几个特性# （1）无序（因此不是序列，不可以通过下标标识来取某个元素，也不可以切片）# （2）不重复#空集合set()type(set()) #这里显示为set类型#集合的几种特殊操作：&gt;&gt;&gt; &#123;1,23,4&#125; - &#123;1&#125; #两个集合的差集&#123;4, 23&#125;&gt;&gt;&gt; &#123;123,5,6,7&#125; &amp; &#123;34,6,8,5&#125; #两个集合的交集&#123;5, 6&#125;&gt;&gt;&gt; &#123;7,5,3,6&#125; | &#123;5,1,8,2&#125; #两个集合的并集&#123;1, 2, 3, 5, 6, 7, 8&#125; 3. 字典 1234567891011&gt;&gt;&gt; &#123;'lbj': '詹姆斯', 'kg': '加内特', 'kb': '科比'&#125;&#123;'lbj': '詹姆斯', 'kg': '加内特', 'kb': '科比'&#125;#字典的典型操作：通过key值取value值操作&gt;&gt;&gt; &#123;'23': '詹姆斯', 5: '加内特', 'kb': '科比',23:'乔丹'&#125;['23']'詹姆斯'&gt;&gt;&gt; &#123;'23': '詹姆斯', 5: '加内特', 'kb': '科比',23:'乔丹'&#125;[23]'乔丹'#注意：（1）key值不能重复；# （2）23是整数值，‘23’是字符串值，因此这两者当作key时是两个不同的key值；# （3）当字典中有两个相同的key值，通过该key值取出来的是后面对应这个value值 4. 不要使用关键字和保留字作变量名 123456789&gt;&gt;&gt; type=1&gt;&gt;&gt; print(type) #正确&gt;&gt;&gt; type(1) #报错#这样会报以下错误：Traceback (most recent call last): File \"&lt;pyshell#15&gt;\", line 1, in &lt;module&gt; type(1)TypeError: 'int' object is not callable#错误即为：不可以把int对象当作函数调用，你已经把type定义为int类型的变量了，所以当你要使用type函数时就会报错。这里的type(1)就相当于1(1),这显然不是一个正确的函数调用。 5. 值类型和引用类型注意：int 、str 、tuple(元组)为值类型（不可改变），list、set、dict为引用类型（可改变）。 123456789101112&gt;&gt;&gt; a=1&gt;&gt;&gt; b=a&gt;&gt;&gt; a=3&gt;&gt;&gt; print(a,b)3 1 #a(int类型)为值类型（不可改变）， b不随a变化而变化，值仍为1。&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=a&gt;&gt;&gt; a[2]='hello'&gt;&gt;&gt; print(a,b)[1, 2, 'hello'] [1, 2, 'hello']# a（list类型）为引用类型(可改变)，b的值随a的改变而改变。 注：123456789101112&gt;&gt;&gt; a='hello'&gt;&gt;&gt; a=a+'python'&gt;&gt;&gt; print(a)hellopython&gt;&gt;&gt; b='hello'&gt;&gt;&gt; id(b)87241952 &gt;&gt;&gt; b=b+'python'&gt;&gt;&gt; id(b)82488640#比较两次id(b)的变化可以知道，执行完b=b+'python'后，b是一个新的字符串了（相当于形成的新字符串存储在新的存储位置，而不是在原字符串的存储位置上进行修改，原字符串并未改变），不是原来的字符串了，因此值类型不可改变。 以下代码也进一步说明了值类型不可以改变：123456789&gt;&gt;&gt; 'python'[0]'p'&gt;&gt;&gt; 'python'[0]='a'#报如下错误：Traceback (most recent call last): File \"&lt;pyshell#9&gt;\", line 1, in &lt;module&gt; 'python'[0]='a'TypeError: 'str' object does not support item assignment 6. 列表的可变与元组的不可变1234567891011121314151617181920#列表的可变&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; id(a)95224576&gt;&gt;&gt; hex(id(a))'0x5ad0300'&gt;&gt;&gt; a[0]='hello'&gt;&gt;&gt; id(a)95224576 #修改列表中某个元素的值后，该列表的id依然未变，说明列表的可变性。&gt;&gt;&gt; print(a)['hello', 2, 3]#元组的不可变&gt;&gt;&gt; a=(1,2,3)&gt;&gt;&gt; a[1]='hello'#当对元组中的元素进行修改时，会报以下错误（说明元组的不可变性）：Traceback (most recent call last): File \"&lt;pyshell#7&gt;\", line 1, in &lt;module&gt; a[1]='hello'TypeError: 'tuple' object does not support item assignment 列表可以利用append函数添加元素1234&gt;&gt;&gt; b=[1,2,3]&gt;&gt;&gt; b.append(4)&gt;&gt;&gt; print(b)[1, 2, 3, 4] 而元组不可以利用append函数添加元素，因为元组不可变12345678&gt;&gt;&gt; c=(1,2,3)&gt;&gt;&gt; c.append(4)#报错Traceback (most recent call last): File \"&lt;pyshell#12&gt;\", line 1, in &lt;module&gt; c.append(4)AttributeError: 'tuple' object has no attribute 'append' 访问元组中的列表的元素（类似于多维数组）123456789&gt;&gt;&gt; a=(1,2,3,[7,8,['hello',9,4]])&gt;&gt;&gt; a[3][2][0]'hello' #以类似于三维数组的方式访问到‘hello’&gt;&gt;&gt; a[3][2][0]='python' #把‘hello’改成python&gt;&gt;&gt; print(a)(1, 2, 3, [7, 8, ['python', 9, 4]])#这里把‘hello’改成了‘python’,#注意：这里之所以可以改变是因为这里改变的是列表，而不是元组。 7. 逻辑运算符 （1）对于int、float类型，0被认为False,非0被认为True；（2）对于字符串（str）类型，空字符串被认为False,非空字符被认为是True；（3）对于列表，空列表被认为是False，非空列表被认为是True；（元组、集合、字典则与此类似） 1234567891011121314&gt;&gt;&gt; 'a' and 'b''b' #相当于True&gt;&gt;&gt; ' ' and 'b' 'b'#注意：' '里面是空格，空格也是字符串，所以' '是非空字符串，相当于True，当第一个元素为True时，则整个与运算的结果由第二个元素决定，因此返回第二个元素。&gt;&gt;&gt; '' and 'b''' #相当于False#当第一个元素为False时，则整个与运算的结果必定为False，因此返回第一个元素。&gt;&gt;&gt; 'a' or 'b''a'&gt;&gt;&gt; '' or 'b''b'#当第一个元素为True时，则整个或运算的结果必然为True，因此返回第一个元素；#当第一个元素为False时，则整个或运算的结果由第二个元素决定，因此返回第二个元素。 8. 成员运算符注意：字典中使用成员运算符，是针对 key而言，而不是value 1234&gt;&gt;&gt; 'lbj' in &#123;'lbj':23&#125;True&gt;&gt;&gt; 23 in &#123;'lbj':23&#125;False 9. 身份运算符注意：关系运算符比较的是值的关系,而身份运算符比较的是身份的关系（即存储地址是否相同）。 1234567891011&gt;&gt;&gt; a=1&gt;&gt;&gt; b=1.0&gt;&gt;&gt; a==bTrue #值相等&gt;&gt;&gt; a is bFalse #身份相同（即存储地址相同）#通过id函数可知1和1.0两者存储的位置不同（即身份不同）&gt;&gt;&gt; id(a)1723716656&gt;&gt;&gt; id(b)87465824 关系运算符和身份运算符在集合中的应用123456&gt;&gt;&gt; a=&#123;1,2,3&#125;&gt;&gt;&gt; b=&#123;2,1,3&#125;&gt;&gt;&gt; a==b True #集合是无序的，只要元素相同，则两个集合的值是相等的。&gt;&gt;&gt; a is bFalse #两者的身份不同（即存储的地址不同） 关系运算符和身份运算符在元组中的应用12345678910&gt;&gt;&gt; c=(1,2,3)&gt;&gt;&gt; d=(3,2,1)&gt;&gt;&gt; c==dFalse #注意：因为元组属于序列，是有序的，顺序不同则两者的值是不同的。&gt;&gt;&gt; c is dFalse #两者的身份不同（即存储的地址不同）#以下证明了元素属于序列&gt;&gt;&gt; (1,2,3)[1]2 10. 判断变量的值、身份与类型 12345&gt;&gt;&gt; type('hello')==intFalse&gt;&gt;&gt; type('hello')==strTrue 注：虽可以通过type函数加关系运算符来判断变量的类型，但是不推荐使用这种方法，因为type不可以判断变量的子类型。 推荐使用isinstance函数来判断变量的类型：1234567&gt;&gt;&gt; isinstance('hello',str)True #‘hello’是str类型&gt;&gt;&gt; isinstance('hello',(int,str,tuple))True #‘hello’是int,str,tuple三种类型中的一种。&gt;&gt;&gt; isinstance('hello',(int,list,tuple))False #‘hello’是int,list,tuple三种类型中的一种。&gt;&gt;&gt; 11. 位运算符无论数字是否是二进制（如八进制，十进制等），都会被转化为二进制进行运算。‘&amp;’（按位与）‘|’（按位或）‘^’（按位异或）‘~’（按位取反）‘&lt;&lt;’（左移动）‘&gt;&gt;（右移动） 12. 表达式表达式（Expression）是运算符（operater）和操作数（operand）所构成的序列。123456789&gt;&gt;&gt; a=1&gt;&gt;&gt; b=2&gt;&gt;&gt; c=3&gt;&gt;&gt; a+b*c7&gt;&gt;&gt; a or b and c1 #结果为1的原因：and的优先级高于or，所以先执行b and c得到结果为3，再执行a or 3得到结果为1。相当于 a or (b and c)# not and or的优先级的顺序是not&gt;and&gt;or. 运算符优先级（注：同一行的优先级没有进行编排） 123456789&gt;&gt;&gt; a=1&gt;&gt;&gt; b=2&gt;&gt;&gt; c=3&gt;&gt;&gt; not a or b+2 ==cFalse&gt;&gt;&gt; (not a) or ((b+2)==c)False#两者是等价的，注意：关系运算符的优先级大于逻辑运算符的，所以'=='的优先级大于not。 13. break 与continue的区别break:123456789A = [1,2,3]for x in A: if x == 2: break #只输出1，后面的2，3以及else中的end字符全都不输出。 print(x)else: print(\"end\")#结果为：1 continue:123456789101112A = [1,2,3]for x in A: if x == 2: continue #跳过2，不输出，其他的（如1，3，end字符）都输出。 print(x)else: print(\"end\")#结果为：1# 3# end 14. 在python中实现类似于其他语言的for(int i=0;i&lt;10;i++)的效果12345#python中的for循环主要用来对序列或集合、字典进行遍历或循环for target_list in expression_list: passelse: pass for与range（1）顺序：12345#类似于其他语言的for(int i=0;i&lt;10;i++)for x in range(0, 10, 2): print(x, end=' | ')#注意：这里不会取到10,‘2’表示间隔量 输出结果为：0 | 2 | 4 | 6 | 8 |（2）逆序：123for y in range(10, 0, -2): print(y, end=' | ')#注意：这里不会取到0,‘2’表示间隔量 输出结果为：10 | 8 | 6 | 4 | 2 | 16. 两种方法实现按某种要求对序列进行访问 下面两者实现效果相同，(1)法一：使用for循环方式123A = [1, 2, 3, 4, 5, 6]for i in range(0, len(A), 2): print(A[i]) (2)法二：使用切片方式（python的特色）123A = [1, 2, 3, 4, 5, 6]B = A[0:len(A):2] #注意这里的‘2’表示步长（即间隔大小）print(B) 17. 导包问题t文件夹下的c1文件：123456#利用__all__=['','']和‘*’可实现选择性导入变量__all__ =['a','b']a = 1b = 2c = 4 与t文件夹在同级目录下的文件：123456789101112131415import t.c1 as mprint(m.a)#引入变量from t.c1 import aprint(a) #引入模块from t import c1print(c1.a)from t.c1 import *print(a)print(b)print(c) #会报错，因为__all__=['a','b']并未包括c. 18. 包的循环引入问题（比较隐蔽） p1.py文件的代码:1234#p1文件引入p2文件from p2 import ba = 1print(b) p2.py文件的代码：1234#p2文件又引入p1文件from p1 import ab = 2print(a) （1）p1文件引入了p2文件，而p2文件则又引入了p1文件，这就导致了循环引入现象，这是一个很隐蔽的错误。（2）当然也可以是多个文件的循环引入，这发现起来更加困难。所以引入包时要尽量避免循环引入包。 19. 入口文件和普通模块 t文件夹下的c4.py代码如下12345678910'''This is a t.c4 doc.'''print('name: '+__name__)print('package: '+__package__)print('doc: '+__doc__)print('file: '+__file__)#print('import: '+__import__) seven文件夹下的c9.py文件代码如下：（注：c9.py和t文件夹位于seven中的同一级目录）12345678910'''This is a seven.c9 doc'''import t.c4print('-----------------c9.py is below---------------')print('name: '+__name__)print('package: '+(__package__ or '当前文件不存在任何包'))print('doc: '+(__doc__ or '当前文件不存在文档注释' ))print('file: '+__file__) 注意入口地址的输入方式不同所引发的变化：图一：图二： 注：c4文件是普通模块，c9是入口文件，入口文件和普通模块在内置变量方面是存在一定的差异的。 注二：(1)利用‘python -m’把可执行文件当作一个模块来运行（把入口文件当作普通模块来执行，不过应注意该指令执行的路径是基于该普通模块的包的上一级目录）。(2)如果作为一个普通模块必须有一个包的。 ‘python -m’指令后面接的是一个命名空间加一个模块名称，而不是文件路径。 20. 判断这是入口文件还是普通文件 12345#判断这是入口文件还是普通文件if __name__ == '__main__': print('This is a entrance document!')else: print('This is a module!') 21. 相对导入和绝对导入（难点）项目文件结构 （1）利用相对导入方式导入上一层目录结构下的m1.py模块：package2\\m1.py文件代码如下:12345''' This is m1.py doc'''m_1 = 1print('m1’s package: '+__package__) package2\\pacakge4\\m2.py文件代码如下:123456''' This is m2.py doc'''from ..m1 import m_1 #引入上一层目录下的m1.py(利用相对导入的方式)m_2 = 2print('m2’s package: '+__package__) LearnPython\\main.py代码如下：12import package2.package4.m2print('main’s package: '+str(__package__)) 输出结果如下： 注：（1）”from xxx import xxx”这样的方式才可以使用相对导入，”import xxx”不可以使用相对导入的方式。（2）绝对导入必须从顶级包开始，如这里的import package2.package4.m2就是采用的绝对导入，package2为顶级包。 (2) LearnPython\\main.py代码如下:12from .package2.package4.m2 import m_2print('main’s package: '+str(__package__)) 结果会报如下错误：注意：（1）一个模块的顶级包与main.py(入口文件)所在的层级有关。（2）main.py是不属于如何包的，这里的LearnPython不是顶级包。（3）package2\\package4\\m2.py的顶级包是package2而不是LearnPython，LearnPython并不是顶级包。 （3）LearnPython\\main.py代码同（2）所示:但是如果利用 ‘python -m’指令把main.py不当作入口文件执行，而当作普通模块来执行，则不会报错。结果执行如下所示：(4) package2\\package4\\m3.py代码如下：12from ...m5 import m_5 #引入上上级目录(即到了LearnPython目录)下的m5.py模块m_3 = 3 LearnPython\\m5.py代码如下：（注意：m5.py和main.py是在同一级目录下）12m_5 = 5print('m5’s package: '+__package__) LearnPython\\main.py代码如下:12from package2.package4.m3 import m_3print('main’s package: '+str(__package__)) 运行时会报如下错误：超越顶级包错误注意：相对导入一定不可超越顶级包。（这里的LearnPython并不是顶级包，package1，package2，package3才是顶级包。） 22. 函数中的关键字参数、默认参数和可变参数 （1）关键字参数：123456789101112'''关键参数默认参数'''def damages(skill1, skill2): damages1 = skill1*3 damages2 = skill2*10 return damages1, damages2skill1_damages,skill2_damages = damages(skill2 = 2, skill1 = 10) #这里括号里面的就是两个典型的关键字参数， #使用关键字参数的一个突出特点就是不用按形参顺序引入实参。print(skill1_damages, skill2_damages) (2)默认参数：12345678910111213def information(name, gender='男', age='25', school='八一小学'): print('姓名： ' + name) print('性别： ' + gender) print('年龄： ' + str(age)) print('学校： ' + school)print('------------------------------------')information('张三', '男', 16, '光明小学')print('------------------------------------')information('李四')print('------------------------------------')information('赵六', '女', 16)print('------------------------------------')information('王二', age=18, school='红旗小学') #修改王二的年龄和学校 注意：（1）不能出现有默认参数和没有默认参数的混在一起，没有默认参数的形参必须放在前面： 如def information(name, gender=’男’, age=’25’, school=’八一小学’，teacher)（2）实参书写时要注意按顺序进行一一对应； 如只要修改‘王二’的年龄，print(‘王二’,18)这样书写是错误的； 应这样书写（使用关键字参数,这样就不用按顺序引入实参了）：print(‘王二’,age=’20’) (3) 可变参数（*param）123456#可变参数def demo(*param): print(param) print(type(param))demo(1,3,4,6,8) 运行结果：（可知可变参数是元组类型的。） 12345678910111213def demo(*param): print(param) print(type(param)) demo((8,9,7,10))demo((1,3,4,6,8),'hello')a = (9,4,5,6)demo(a)b = (8,3,6,8) demo(*b) #实参里面加‘*’相当于序列解包。要传递元组，调用时需加上‘*’ 运行结果： 注意必须参数、关键字参数、默认参数和可变参数混合的几种情况：123456#必须参数必须放在可变参数之前#param为必须参数，param2为默认参数，param为可变参数def demo(param1,param2 = '4',*param): #可变参数放在默认参数之后 print(param1, param2, param)demo(1,2,3,4) 运行结果：（一 一 对应，多余的全部当作元组对应于可变参数） 1234def demo(param1,*param,param2 = '4'): #可变参数放在默认参数之前 print(param1, param2, param)demo(1,2,3,\"hello\") 运行结果: 要实现使‘hello’对应于默认参数可以利用关键字参数实现：1234def demo(param1,*param,param2 = '4'): print(param1, param, param2)demo(1,2,3,param2 =\"hello\") #利用关键字参数方法（param2 = 'hello'）把默认参数的实参值指定为‘hello’ 运行结果： 23. 关键字可变参数 12345678910格式：def demo(**param): pass(1)这样在调用时可以传递多个关键字参数，此时python会将其转化为字典类型dict。(2)若调用时想传递字典类型而不转化为多维数组，调用时需加上**。a=&#123;'bj':'32c','sh':'31c'&#125;demo(**a)(3)遍历字典类型数据方法：(注：param为关键字可变参数即**param)for key,value in param.items(): print(key, ':', value) 例如：1234567891011def city_weather( **param1): print(param1) print(type(param1)) for key,value in param1.items(): #print(key+' : '+value) 这种输出方法也可以,输出效果与下面相同 print(key, ':', value) city_weather(bj='10c', sh='20c', nc='18c')a = &#123;'nb':'15c', 'hz':'16c', 'ja':'19c'&#125;city_weather(**a) 运行结果： 24. 全局变量和局部变量 12345678910def demo(): c = 20 # a = '' 在其他语言要加上这行，才能在for循环外面引用a变量， # 而Python不用加这行也可以在for循环外面引用a变量，因为python没有块级作用域（for,while）的概念 for i in range(0,6): a = 'abc' c += 1 print(c) print(a)demo() 注意：（1）Python和其他语言的一个重要区别：Python没有块级作用域的概念！！！（2）函数内部for循环外部可以引用for循环内部的变量（3）python中可以在for循环外部访问for循环内部定义的变量，if-else和while也是如此!!因为在python里for、while和if-else不能形成作用域。所以其中的变量视作与函数内变量同一级别。代码块无法形成一个作用域 一个问题：为何全局变量不能在函数内部的for循环内部使用1234567c = 50def demo(): #c = 20 for i in range(0,6): c += 1 print(c)demo() c变量不是全局变量吗？为什么还会报“局部变量引用前应该先赋值”的错误？ 25. global关键字的使用（将局部变量转变为全局变量） 123456def demo(): global c c = 2demo() #注意不要忘了调用函数！！！print(c) #c变成全局变量之后，函数外部也可以引用该变量。#结果将打印c的值 注：使用import 导入该模块后，其他模块也可以使用该模块的全局变量。 26. 类和对象（重点和难点）、面向对象思想 12345678910111213141516171819202122232425'''（1）有意义的面向对象的代码（2）类 = 面向对象（3）类、 对象（4）实例化（类和对象就是通过实例化关联起来的；）（5）类基本的作用是封装代码（6）在类的内部不能执行类中的方法，类只负责定义，类的方法必须在类的外面调用执行（7）不推荐在同一模块下面即定义类，又调用执行类中的方法，类的定义和调用类中的方法最好放在不同的模块中。（8）类经过实例化后得到一个具体的对象（类就像一个打印机，通过一个打印机可以产生各种各样的对象）（9）可以把类中的数据成员（变量）当作类的特征、把类中的函数当作类的行为，在类中，行为与特征是两大要点。（10）类的定义：类似现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。'''class Student(): name = 'lee' age = 18 def stu_information(self): #类中的函数定义一定要加‘self’关键字 print('姓名： ' + self.name) #在引用类中的变量时也需要在变量之前加上‘self’关键字(如self.name) print('年龄： ' + str(self.age))#不推荐在同一模块下面即定义类，又调用执行类中的方法，类的定义和调用类中的方法最好放在不同的模块中。# student = Student() #类的实例化# student.stu_information() #调用类中的方法 27. 构造函数 （1）构造函数只能返回None类型，不能定义返回其他类型。（2）构造函数通常用于初始化对象的属性。123456789101112131415class Student(): name = 'lee' age = 18 def __init__(self,name,age): #构造函数 #构造函数初始化对象的属性 self.name = name #等号左边为定义的实例变量，等号右边表示要传的参数。 self.age = agestudent = Student('kg',15) #在类的实例化的时候，就调用了一次构造函数。注意：实例化时一定要记得加上与构造函数的形参相对应的实参。a = student.__init__('kb',36) #构造函数也可以显式调用，如student.__init__('kb',36)print(a)print(type(a))print(student.name)print(student.age) 运行结果： 构造函数初始化对象的属性的方式：123def __init__(self,name,age): self.name = name self.age = age 28. 类变量和实例变量的区别（重点与难点） （1）类变量是与类相关的变量，不受对象的影响；（2）实例变量是与对象相关的变量，受对象的影响；12345678910111213141516class Student(): #类变量 name = 'lee' age = 18 #类变量：与类相关的变量，实例变量：与对象相关的变量 def __init__(self,name,age): #实例变量 #这里的self后面的name是实例变量，通过\"self.实例变量名\"的方式定义实例变量 self.name = name #等号左边为定义的实例变量，等号右边表示要传的参数。 self.age = agestudent1 = Student('王二小',16)student2 = Student('刘胡兰',20)print(student1.name)print(student2.name) #实例变量与对象相关，不同对象的实例变量的值不同print(Student.name) #类变量只与类有关，与对象无关 运行结果： 29. 类与对象的变量查找顺序 （1）错误的实例变量定义方式导致的后果：12345678910111213141516171819class Student(): #类变量 name = 'lee' age = 18 #类变量：与类相关的变量，实例变量：与对象相关的变量 def __init__(self,name,age): #正确的实例变量的定义方法 # self.name = name # self.age = age #这里使用错误的实例变量定义方法，这样就会导致对象不存在变量（即实例变量），所以显示出来的对象的属性字典（变量字典）为空。 name = name age = age#__dict__ : 类的属性（包含一个字典，由类的数据属性组成）student1 = Student('王二小',16)print(student1.__dict__) #对象的属性字典print(Student.__dict__) #类的属性字典 运行结果：（2）正确的实例变量定义方法的运行结果为：（3）12345678910111213class Student(): #类变量 name = 'lee' age = 18 #类变量：与类相关的变量，实例变量：与对象相关的变量 def __init__(self,name,age): #这里使用错误的实例变量定义方法，这样就会导致对象的实例变量表为空，所以当在该表中寻找某个实例变量时，是找不到的。 name = name age = agestudent1 = Student('王二小',16)print(student1.name) #对象的实例变量print(Student.name) #类变量 运行结果：注意：python寻找变量的机制：当python尝试去寻找一个实例变量时，首先在对象的实例变量表中寻找，如果没有找到则继续在类变量表中寻找，如果有父类，则继续父类的类变量表中寻找，而不是直接返回None。 30. self 与实例方法 （1）python中类的实例方法的参数列表中需要有self，但是在调用时不需要传入。在实例方法中也可以将self定义成别的名字（如this），但python建议为self。 （2）self 就是当前调用的某一个方法的对象123456789#下面两种都可以称为实例方法 def __init__(self,name,age): self.name = name self.age = age def stu_information(self): print('姓名： ' + self.name) print('年龄： ' + str(self.age)) 31. 在实例方法中访问类变量的方法以及在类外部访问实例变量的方法 (1) 在实例方法中访问实例变量: self.变量名(2) 在实例方法中访问类变量:①类名.变量名 ②self.class.变量名(3) 在类外部访问类变量:①类名.变量名 ②实例.变量名12345678910111213141516171819class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 def __init__(self,name,age): self.name = name #等号左边为定义的实例变量，等号右边表示要传的参数。 self.age = age print(self.name) #打印的是实参变量的值 print(name) #打印的是传递的形参值 print(Student.name) #打印的是类变量的值 print('在实例方法中访问类变量的方法一：', Student.sum1) #打印的是类变量sum1的值 print('在实例方法中访问类变量的方法二：', self.__class__.sum1) #打印的是类变量sum1的值student = Student('叮当',12)print('在类的外部访问类变量的方法：', Student.sum1) #在类的外部访问类变量 32. 类方法 (1) 类变量的使用的一个小例子：每次把一个类实例化成对象，类变量sum1就加1123456789101112131415class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 def __init__(self,name,age): self.name = name self.age = age self.__class__.sum1 += 1 print('当前学生人数为：',self.__class__.sum1)student1 = Student('叮',11)student2 = Student('当',12)student3 = Student('叮当',13) (2)类方法定义和调用 1234567891011121314151617181920212223242526272829'''类方法'''class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 #实例方法 def __init__(self,name,age): self.name = name self.age = age #类方法 @classmethod def plus_sum(cls): cls.sum1 += 1 print(cls.sum1)student1 = Student('叮',11)#调用类方法：类名.类方法Student.plus_sum() #这里虽然可以使用对象调用类方法如\"student1.plus_sum()\"， #但是不建议这样做，这样容易导致逻辑混乱。student2 = Student('当',12)Student.plus_sum()student3 = Student('叮当',13)Student.plus_sum() 注：（1）这里的cls表示class类，也可以使用别的名字表示，但是建议使用cls这个名字作为参数。（2）此外，类方法中操作类变量，直接使用‘cls.类变量’即可。而且python里对象也可以调用类方法。 33. 静态方法 123456789101112131415161718192021222324252627282930313233343536'''静态方法'''class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 def __init__(self,name,age): self.name = name self.age = age #类方法 @classmethod def plus_sum(cls): cls.sum1 += 1 print(cls.sum1) # print(self.name) #会报错：self没有定义。所以类方法中不能访问实例变量 print(name) #去掉self也会报错：name没有定义。且去掉name就不是访问实例变量了。 #静态方法 @staticmethod def add(x, y): print(Student.sum1) #静态方法可以访问类变量，不过只能使用“类名.类变量”的方式 # print(self.name) #会报错：self没有定义。所以静态方法中不能访问实例变量 print(name) #去掉self也会报错：name没有定义。且去掉name就不是访问实例变量了。 print('This is a static method!') student1 = Student('叮',11)#调用类方法：类名.类方法Student.plus_sum() #调用静态方法（类和对象都可以调用静态方法）student1.add(1, 3) #通过对象调用静态方法Student.add(2, 4) #通过类调用静态方法 注：（1）静态方法无需传入类似self，cls之类的参数，而且它可以被对象和类调用。静态方法可以访问类变量。（2）静态方法和类方法都不可以访问实例变量。（3）尽量少用静态方法，因为它和类与对象的关系很弱，和普通函数区别不大。当某个方法比较纯粹，与类和对象的关系不是很强，可以考虑静态方法。 34. 成员的可见性：公开与私有 （1）改变类下面的变量的值最好用方法，不要直接对变量进行更改。123456789101112131415161718192021class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 def __init__(self,name,age): self.name = name self.age = age self.score = 0 def marking(self, score): if score &lt; 0 : score = 0 return '不能打负分！' self.score = score print(self.name + '同学的分数为：'+ str(self.score)) student1 = Student('叮',11)#student1.score = -1 #修改类下面的变量不应该直接对变量进行更改。result = student1.marking(66) #而应该通过方法进行更改。print(result) （2）为了防止直接对类下面的变量进行更改，可以通过成员的可见性进行控制，将成员设置成私有即可。 123#私有方法 def __func(self,param): self.__param = 0 #私有变量：变量名之前加双下划线 注：(1) python中定义私有变量或私有方法只需在名称前加双下划线即可，但若在名称结尾也加了双下划线则不是私有的。(2) 应尽量避免定义开头和结尾都有双下划线的变量或函数名称。 (3) 实例私有变量1234567891011121314151617181920212223242526272829303132'''成员可见性:公开和私有'''class Student(): #类变量 sum1 = 0 name = 'lee' age = 18 def __init__(self,name,age): self.name = name self.age = age self.__score = 0 #类中的score实例变量已被定义为私有实例变量 def marking(self, score): if score &lt; 0 : score = 0 return '不能打负分！' self.__score = score print(self.name + '同学的分数为：'+ str(self.__score))student1 = Student('叮',11)result = student1.marking(66) print(result)student1.__score = -1 #这里的__score便不是上面的私有类中的实例变量__score,这是两回事。这是一个新的实例变量。print(student1.__score)print(student1.__dict__)student2 = Student('王二小',14)print(student2.__score) #会报错，因为Student的__score是私有实例变量，在类的外部是访问不到的。 运行结果如下：将上面的1print(student2.__score) 改为1print(student2._Student__score) #注意：Student前面是单下划线 是可以访问到私有实例变量的。 35. 继承（重点和难点） 父类文件1234567891011'''继承这是父类文件'''class Human(): sum1 = 0 def __init__(self, name, age): self.name = name self.age = age def do_work(self): print('This is a parent method !') 子类文件：1234567891011121314151617181920212223'''继承这是子类文件'''from n10 import Humanclass Student(Human): def __init__(self, school, name, age): #子类的构造函数要引入父类的构造函数中的参数 self.school = school #Human.__init__(self, name, age) #注意：使用类调用父类的构造函数需要引入self参数。因为这就是一个普通的方法调用，没有人帮忙把self参数传入进去，所以需要把所有的参数传入进去。 super(Student,self).__init__(name,age) #推荐使用这种方法调用父类中的构造函数，这种方法也可以用于调用父类中的实例方法。 def do_work(self): super(Student, self).do_work() #调用父类中的实例方法 print('Studying!!! ')student1 = Student('八一小学','王二小',18) #而这里之所以不用传入self参数，是因为在实例化的时候Python自动把self参数传入了。print(student1.sum1) #通过对象访问类变量（继承自父类）print(Student.sum1) #通过类访问类变量print(student1.school) #通过对象访问实例变量(子类特有的)print(student1.name) #通过对象访问实例变量（继承自父类）print(student1.age)student1.do_work() #而这里之所以不用传入self参数，是因为这里是通过student1对象来调用方法的，self在这里就是指代student1对象，调用会自动把student1这个对象传入进去 调用父类中的构造函数(两种)：方法一：1Human.__init__(self, name, age) 方法二：1super(Student,self).__init__(name,age) #推荐使用这种方法调用父类中的构造函数，这种方法也可以用于调用父类中的实例方法。 调用父类中的实例方法:1super(Student, self).do_work() #调用父类中的实例方法 一个重要的对比及区别：(1) 使用类调用父类的构造函数需要引入self参数。因为这就是一个普通的方法调用，没有人帮忙把self参数传入进去，所以需要把所有的参数传入进去。1Human.__init__(self, name, age) (2)这里之所以不用传入self参数，是因为在实例化的时候Python自动把self参数传入了。1student1 = Student('八一小学','王二小',18) (3)这里之所以不用传入self参数，是因为这里是通过student1对象来调用方法的，self在这里就是指代student1对象，调用会自动把student1这个对象传入进去1student1.do_work() 36. 正则表达式 正则表达式:是一个特殊的字符序列,用于检测一个与我们设定的字符序列是否相匹配.如：快速检索文本,实现一些文本替换.检测一串数字是否是电话号码.检测一个字符串是否符合 email 的标准把一个文本里指定的单词替换成另外一个单词.(1)小试牛刀： 12345678910111213141516171819'''正则表达式'''import rea = 'c++|java|c|C#|javascript|python'#（1）使用内置方法判断是否a变量中是否存在某个字符串r = a.index('python') &gt; -1 #大于-1说明存在print(r)#(2)用in关键字也可以判断a变量是否存在某个字符串r1 = 'python' in aprint(r1)#(3)通过正则表达式判断a中是否存在某个字符串result = re.findall('python',a) #返回为listprint(result)if len(result) &gt; 0: print('a中存在python这个字符串！')else: print('a中不存在python这个字符串！') (2)正则表达式之字符集：12345678910111213'''正则表达式之字符集'''import res = 'abcd,haha,hell,appl,afcd,efdg,accd'r1 = re.findall('a[bf]cd', s) #查找第二个字符是b或f字母的字符串，且第一个字符为a,第三个为c,第四个为dprint(r1)r2 = re.findall('a[b-f]cd', s) #查找第二个字符是b到f字母中的一个字母的字符串，且第一个字符为a,第三个为c,第四个为dprint(r2)r3 = re.findall('a[^bf]cd', s) #查找第二个字符既不是b也不是f的字符串，且第一个字符为a,第三个为c,第四个为dprint(r3) （3）正则表达式之概括字符集 常见的概括字符集：\\d: 0-9的数字，等价于[0-9]\\D: 非数字，等价于[^0-9]\\w：匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9]”，这里的”单词”字符使用Unicode字符集。\\W：匹配任何非单词字符。等价于“[^A-Za-z0-9]”。\\s：匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]\\S：匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v] (4) 数量词(1)数量词可以控制正则表达式选取的字符的长度，但是感觉按照数量词从大到小进行匹配，遇到不符合表达式的字符就停止，到新的字符重新开始匹配。因此，案例中每个单词后边因为有了空格、数字才使得{3,6}数量词成立，如果将这些非单词字符去掉，那么输出的就都是按照最大的数量词匹配出来的字符。(2)而且数量词并不只是在匹配单词的时候可以用，数字也可以。(3)python在进行正则表达式匹配时倾向于贪婪。在匹配字符串时若在结尾加上?则可进行非贪婪匹配。1234567import rea = 'Java45python html&amp;php'#找出a中的字符个数在3到6个的单词r1 = re.findall('[A-Za-z]&#123;3,6&#125;', a) #贪婪：尽可能地按最大数量词匹配单词。（如这里的python是从起始字符p开始后面一直到第6个都是字符，所以都匹配选取出来。）print(r1)r2 = re.findall('[A-Za-z]&#123;3,6&#125;?', a) #非贪婪（后面加问号）：尽可能地按最小数量词匹配单词(如这里匹配到3个字符就结束了匹配)print(r2) 运行结果：（5）匹配0次、1次或无限次 ‘*’ ： 0次或无限多次‘+’ ： 1次或无限多次‘?’ ： 0次或1次123456789101112import rea = 'pytho0python1pythonn2'#r1 = re.findall('python*', a) # *号表示*号前面的n字母出现0次或无限多次print(r1)r2 = re.findall('python+', a) # +号表示+号前面的n字母可以出现1次或无限多次print(r2)r3 = re.findall('python?', a) # ?号表示?号前面的n字母可以出现0次或1次print(r3) #这里输出的第三个元素是'python'r4 = re.findall('python&#123;1,2&#125;', a) #注意与?号的区别print(r4) #注意这里选取匹配时采用的是贪婪模式，所以输出的第二个元素是'pythonn'(多一个n) 运行结果：（6） 边界匹配符 ^ : 起始边界符$ : 结束边界符123456789101112131415'''正则表达式之边界匹配符'''import reqq = '10005000'r1 = re.findall('[0-9]&#123;4,8&#125;', qq) #这种方式排除位数小于4位的QQ号，但是不可以排除位数大于8位的QQ号，当大于8位时，会截取前8位print(r1)r2 = re.findall('^\\d&#123;4, 8&#125;$', qq) #筛选位数为4到8位的QQ号print(r2)#效果与上面相同# r2 = re.findall('^[0-9]&#123;4, 8&#125;$', qq) #筛选位数为4到8位的QQ号# print(r2) (7) 组注：( )可以在正则表达式中使用组的概念,( )里的元素是且关系，[ ]里的元素是或关系。1234567import rea = 'pythonpythonuythonpythonpython'r1 = re.findall('(python)&#123;3&#125;', a) #表示Python以组的形式匹配 连续出现3次才算匹配成功#返回的值（即r1的值）为['python'],若不存在连续3个python，则返回[]即空列表print(r1) (8) 匹配模式 12345678910111213141516'''正则表达式之匹配模式re.I 表示匹配时忽略大小写re.S 表示匹配时匹配所有字符包括换行符（\\n）. 表示匹配除换行符（\\n）以外的所有字符re.S 可以影响'.'的行为，平时'.'表示匹配除换行符之外的所有字符，加入re.S匹配模式之后，'.'就可以匹配所有的字符（包括换行符）'''import rea = 'javaC#\\nPythonC++'#r1 = re.findall('c#.&#123;1&#125;',a , re.I) #忽略大小写匹配c#然后匹配任意一个字符（不包括'\\n'即换行符）r1 = re.findall('c#.&#123;1&#125;', a, re.I | re.S) #忽略大小写匹配c#然后匹配任意一个字符（包括'\\n'即换行符）print(r1) 运行结果：（9）re.sub正则替换 （1）re.sub(‘正则表达式’,’即将覆盖原有字符串的新字符串’,”老字符串”,该字符被替换的次数,正则表达式的附加条件)（2）替换的次数（count）为0表示为无限替换，如果为1则表示第一次匹配成功后替换，之后不再匹配替换。（3）如果定义一个函数后 替换位置可以换成函数def convert(value): passr = re.sub(“C#”,convert,lanuage,0)1234567891011121314151617181920import rea = 'pythonjavaC#htmlC#javascriptC##c++'re.sub('C#', 'Go', a, 3) #只有把该函数返回值赋值给新的字符串才能使输出的结果发生改变，因为字符串是不可改变的。print(a)r1 = re.sub('C#', '__Go__', a, 1) # count=0(默认值),也依然会把字符中的三个C#全部替换，设置成1则只替换第一个。（count=0表示无限次替换）print(r1) r2 = a.replace('C#','__Ruby__') #如果只是简单进行一些字符的替换可以使用“字符串.replace()\"的内置函数完成print(r2)def convert(value): print(value) #注意观察value的值 matched = value.group() #group()是获取当前匹配的内容 return '!!_' + matched +'_!!'r3 = re.sub('C#', convert, a, 3)print(r3) 运行结果： re.sub( )中为何要引入函数参数，其一个原因就是引入函数可以写一些具体的逻辑，这是相比只能引入一些变量参数而言的一个极大的优势。如下所示：12345678910111213import rea = 'AB389408HE67632'def convert(value): matched = value.group() if int(matched) &gt;= 6: return '9' else: return '0'r1 = re.sub('\\d',convert ,a) #将字符串中是数字的且大于6的全部转换为9，小于6的全部转换为0print(r1) （10）match 和 search函数 match函数：从字符串开始位置（即首字符）开始匹配，匹配成功则返回一个对象，否则返回None。search函数：搜索整个字符串，找到第一个匹配的结果，则返回一个对象；如果没有一个符合条件的结果，则返回None。注：（1）可以使用group函数从对象取出符合的结果的内容。（2）这两个函数一旦匹配到结果就立即返回，而停止匹配（这是与findall函数的最大区别）。（3）findall函数返回结果为list类型， match与search返回类型为对象（如果需要获取对象截取内容 需要用group( )方法）12345678910111213141516'''正则表达式之match和search函数'''import res = 'WA6fj4a52f34hfu'r1 = re.match('\\d', s) # match函数是从第一个字符开始匹配，如果不符合条件就返回None，如果符合就返回包含该字符的对象。（如这里因为第一个字符为W，不是数字，所以返回None）print(r1)r2 = re.search('\\d', s) # search函数是匹配选取出第一个包含符合条件的值的对象。（如这里为第一个符合的值为6）print(r2)print(r2.group()) #用group获取匹配的值的内容r3 = re.findall('\\d', s) # findall函数是匹配所有符合条件的值，而search 和 match函数只匹配选取出第一个符合条件的值。print(r3) 运行结果： （11）group分组 12345678910111213'''正则表达式之group分组'''import re s = 'life is short,i use python,i love python'r1 = re.search('life(.*)python(.*)python',s) #（.*）表示一个分组，括号表示一个分组。print(r1.group(0)) # group(0)是一种特殊情况，返回的是正则表达式的完整匹配结果print(r1.group(1)) # 如果要返回完整匹配结果中的第1个分组应使用group(1),表示匹配中间的第一个分组print(r1.group(2)) # group(2)表示完整匹配结果中间的第2个分组print(r1.group(0, 1, 2)) #可以使用这一行代码，返回上面三行代码的返回结果，返回的形式是以元组形式print(r1.groups()) #用groups()返回完整匹配结果中间的所有分组，以字符串元组的形式返回 运行结果：注：‘ .* ‘表示匹配所有字符（除换行符以外）无限次，常用于模糊查询（匹配）。 37. JSON （1）JSON全称为JavaScript Object Notation即JavaScript对象标记。（2）JSON 是一种轻量级的数据交换格式 。（3）符合JSON格式的字符串叫作 JSON字符串。（4）JSON 的优势： 1. 易于阅读 2. 易于解析 3. 网络传输效率高 4. __适合跨语言交换数据__ 38. 反序列化 反序列化：将某种格式的（如JSON格式）数据类型转化为特定语言（如Python）的数据类型的过程1234567891011121314import jsonjson_str = '&#123;\"name\": \"王二小\", \"age\": 15, \"girl\": false&#125;' #注意：JSON数据格式中字符串用“双引号”括起来，JSON数据格式是与语言无关的，这点很容易造成错误。json_array = '[&#123;\"name\": \"王二小\", \"age\": 15, \"girl\": false&#125;, &#123;\"name\": \"刘胡兰\", \"age\": 18, \"girl\": true&#125;]'r = json.loads(json_str) #使用json.loads()函数把json数据格式转化为Python相应的数据格式，#（1）JSON中的&#123;key:value,...&#125;格式（即JSON的一个数据对象）对应于Python中的字典数据类型（dict）#（2）JSON中的array（数组）如（[&#123;\"name\":\"王小二\",...&#125;,&#123;\"name\":\"刘胡兰\", ...&#125;]）对应于Python中的列表类型（list）print(type(r))print(r)print(r['name']) #通过字典的访问数据项的形式就可以访问某个数据项的值print(r['age']) r1 = json.loads(json_array)print(type(r1))print(r1) 运行结果： JSON数据类型与Python数据类型的对应关系 JSON Python object dict array list string str number int number float true True false False null None 39. 序列化 序列化：特定语言下（如Python）的数据类型转化为某种数据格式的数据类型（如JSON）的过程。123456789101112131415'''序列化：特定语言下（如Python）的数据类型转化为某种数据格式的数据类型（如JSON）的过程json.loads() 用于反序列化json.dumps() 用于序列化'''import json#python下的列表数据类型student = [ &#123;'name':'熊大', 'age':16, 'male':True&#125;, &#123;'name':'熊二', 'age':13, 'male':True&#125; ] r = json.dumps(student) #序列化：这里Python下的列表数据类型（list）转化为JSON字符串,在JSON数据格式里就是array类型print(r)print(type(r)) # 转化之后的结果放在Python就是str类型 运行结果： 40. 序列化和反序列化的区别 (1) 反序列化：将某种格式的（如JSON格式）数据类型转化为特定语言（如Python）的数据类型的过程(2)序列化：特定语言下（如Python）的数据类型转化为某种数据格式的数据类型（如JSON）的过程(3) json.loads() 用于反序列化(4) json.dumps() 用于序列化 41. JSON理解的一些常见误区 （1）应该跳出特定语言的范畴来理解JSON. (JSON并不是专属于特定语言里的，如JavaScript)（2）JSON和JavaScript一样，都是W3C标准script（ECMA Script）的实现方式之一。由于JS是目前主流的Web前端语言，而JSON被大量用于JavaScript的交互层, 因此常被误解为附属于JavaScript。（3）JSON对象：JSON本身没有对象的概念，通常这个问题是关联到javascript里时带出来的。（4）JSON有自己的数据类型（虽然和Javascript的数据类型有些类似），JSON更多的是作为不同语言传输数据的中间类型（即 JSON是一种中间数据类型）。（5） JSON字符串：符合JSON数据格式的字符串。（6）REST服务的标志性特点就是轻量，正好与JSON的特点相匹配，因此在REST服务中应该多采用JSON而不是XML 42. 枚举类型 (1) python中所有枚举类型都是enum模块下Enum类的子类。(2) 枚举中的标识最好全部使用大写。 12345678from enum import Enum #从内置的enum模块下导入Enum类class VIP(Enum): YELLOW = 1 GREEN = 2 BLCAK = 3 RED = 4print(VIP.YELLOW) #输出的结果为VIP.YELLOW 注：枚举的意义重在标签而不在于数值，使用print(VIP.YELLOW)打印结果不是1而是VIP.YELLOW，这也符合枚举的意义。(3) 枚举的优点： 定义枚举类后不能从外部更改标签属性。(枚举类型中的值不能更改。) 12#这样并不能更改枚举类型变量的值，会报错。VIP.YELLOW = 6 可以防止相同标签的定义。 123#相同标签是不可以重复定义的YELLOW = 1YELLOW = 2 1234#在枚举中YELLOW和GREEN的是可以相同的#枚举类中不同枚举类型的值可以相同，但此时这两个枚举类型中的第二个名称是第一个的别名，建议使用第一个的名称+_ALIAS作为名称。YELLOW = 1GREEN = 1 #GREEN就相当于YELLOW的别名，并不是一个独立的枚举类型 (4)用字典类型和类表示枚举值的缺点： 可变 12#改变类变量的值（假设name为Student类的类变量）Student.name = 'wanger' #是可修改的（即可变） 没有防止相同值的功能。如： 1&#123;'YELLOW':1, 'GREEN':1&#125; #字典中值相同是可以的 （5）枚举类型，枚举名字，枚举值1234567891011121314151617181920212223'''枚举类型，枚举的名字，枚举值'''from enum import Enumclass VIP(Enum): YELLOW = 1 GREEN = 2 BLACK = 3 RED = 4print(VIP.GREEN) #枚举类型,返回VIP.GREENprint(type(VIP.GREEN)) #返回结果为&lt;enum 'VIP'&gt;print(VIP.GREEN.name) #枚举名字（是str类型）,返回GREENprint(type(VIP.GREEN.name)) #返回结果为&lt;class 'str'&gt;print(VIP.GREEN.value) #枚举值print(VIP['GREEN']) #表示通过枚举名字获取枚举类型，返回VIP.GREEN#利用for循环遍历枚举类中的枚举类型for v in VIP: print(v) （6） 枚举类型比较 (1). 枚举类型之间可以进行等值比较(==)，但直接和数值比较会返回False，如： VIP.GREEN == 2 返回False(2). 枚举类型之间不支持大小比较操作符(&gt;、&lt;)的.(3).枚举类型可以进行身份比较(is)，如：VIP.GREEN is VIP.GREEN 返回 True(4). 不同枚举类中的枚举类型进行比较都会返回False。123456789101112131415161718192021222324252627282930from enum import Enumclass VIP(Enum): YELLOW = 1 GREEN = 2 BLACK = 3 RED = 4class VIP1(Enum): YELLOW = 1 GREEN = 2 BLACK =4 RED = 3r1 = VIP.GREEN == VIP.GREEN #返回True，枚举类型之间可以进行等值比较print(r1)r2 = VIP.GREEN == VIP.YELLOW #返回Falseprint(r2)r2_1 = VIP.GREEN == VIP1.GREEN #返回False，不同枚举类中的枚举类型进行比较时会返回False，即使两者的值相等print(r2_1)r3 = VIP.GREEN == 2 #返回False，因为枚举类型不可以直接与数字进行等值比较 print(r3)# r4 = VIP.GREEN &gt; VIP.YELLOW #会报错，因为枚举类型不可以进行大小比较# print(r4)r5 = VIP.GREEN is VIP.GREEN #返回True，枚举类型可以进行身份比较（is）print(r5) (7) 枚举的一些常见误区12345678910111213141516171819from enum import Enumclass VIP(Enum): YELLOW = 1 YELLOW_ALIAS = 1 #这是别名（值相同） BLACK = 3 RED = 4#利用for循环只能遍历枚举类中的枚举类型（不包括别名）for v in VIP: print(v)#别名也会被遍历，打印出枚举名字for v in VIP.__members__: print(v) #以元组的形式显示for v in VIP.__members__.items(): print(v) 注：枚举类中不同枚举类型的值可以相同，但此时这两个枚举类型中的第二个名称是第一个的别名，建议使用第一个的名称+_ALIAS作为名称。（8）由枚举类型的值获取枚举类型（枚举转换）123#通过数值获取枚举类型 枚举类名(枚举类型的值)a = 1print(VIP(a)) （9）枚举的小结 （1）python中枚举类是通过单例实现的，无法实例化。（2）使用enum模块中的unique装饰器可以避免一个枚举类中出现值相同的枚举类型（3）enum模块中的IntEnum类被继承后，定义的枚举类型的值只能为int类型1234567from enum import IntEnum,unique@uniqueclass VIP(IntEnum): YELLOW = 1 GREEN = 1 #会报错：加了“@unique”的装饰器，枚举类型不能出相同的值。 BLACK = 'str' #会报错：继承了IntEnum类，枚举类型的值只能为int类型的 RED = 4 43. 函数 (1) python中一切皆对象，函数也是对象。(2) python中的函数不仅可以赋值给变量，还可以作为另外一个函数的参数传递，也可以作为另外一个函数的返回结果。 44. 闭包（难点！！！！！） 1234561.python在函数内部还可以定义函数，但该函数作用域只在外部函数内部有效，除非作为外部函数的返回值被返回，在外部函数的外部用一个变量接收后就可以调用它了。2.python中闭包的定义：由函数及其在定义时外部的环境变量（不能是全局变量）构成的整体。闭包 = 函数 + 环境变量（函数定义时候）3.f.__closure__ 返回环境变量，此时的环境变量为一个对象 f.__closure__[0].cell_contents 返回环境变量的值4.f()指调用函数 123456789101112def curve_pre(): a = 25 #如果a = 25(闭包中的环境变量)放在curve函数中就不是闭包了，必须放在curve之外和curve_pre之内 def curve(x): return a * x * x return curvea = 10 #如果前面的a = 25被注释，则a取值为这里的10#闭包中的环境变量a（即a=25）被调用，全局变量a（即a=10）不会被调用，没有才被调用.f = curve_pre()print(f(2))print(f.__closure__) #返回环境变量，是一个对象print(f.__closure__[0].cell_contents) #返回环境变量的值 运行结果： （1）闭包的意义在于保存了一个环境。尤其是函数中调用函数时，如果没有闭包，很容易被外部变量所影响。 （2）闭包必须满足2个条件，函数嵌套函数，并且内部函数需要引用外部函数的变量（环境变量）。 未构成闭包情况：123456789def f1(): a = 1 def f2(): a = 2 # 此时a被Python认为是一个局部变量，与外面的a是没有关系的，并没有去引用外面的环境变量，所以此时闭包是不存在的，且这与闭包的意义在于保存了一个环境。尤其是函数中调用函数时，如果没有闭包，很容易被外部变量所影响，而且这与f2()函数有没有返回结果没有关系.(此时a已经被重新赋值) return f2f = f1()f()print(f)print(f.__closure__) 运行结果：构成闭包情况：123456789def f1(): a = 1 def f2(): c = 2 * a #闭包的环境变量不能在函数里被重新赋值 return f2f = f1()f()print(f)print(f.__closure__) 运行结果： 45. 旅行者行走问题解决方法：非闭包方法和闭包方法 （1）非闭包方法12345678910111213'''旅行者行走问题（1）用非闭包的方法'''x = 0def position(move): global x #将 x 声明为全局变量，这样函数内部的x就会被全部当作全局变量，而不是局部变量 new_pos = x + move x =new_pos # 如果没有\"global x\"声明，这里就会把x当作局部变量，从而会报局部变量未被定义的错误。 return xprint(position(3))print(position(4))print(position(6)) 运行结果： 注：即便是此变量被赋值为全局变量，但如果在函数内部出现了变量赋值，即使出现在函数最后一条语句，这个变量也会被认为是局部变量，执行时不再往外找值，赋值前使用报未定义的错误。解决办法之一是将变量赋值为global。（2）闭包方法 闭包有保存现场的一个功能，有记忆性。12345678910111213141516'''旅行者行走问题（2）用闭包的方法'''origin = 0def position(pos): def go(step): nonlocal pos #定义pos为非局部变量，这里的pos是环境变量。从而形成闭包。 new_pos = pos + step pos =new_pos return pos return gof = position(origin)print(f(3))print(f(4))print(f(6)) 运行结果： 46. 匿名函数 1234567891011'''匿名函数'''#普通函数def add(x, y): return x + yprint(add(1,3))#匿名函数(定义函数时不需要函数名)#lambda parameter_list(变量列表): expression（只能是表达式，不能是代码块）reslut = lambda x, y: x + yprint(reslut(1,3)) 47. 三元表达式 123456#三元表达式#其他语言的写法一般为：x &gt; y ? x : yx = 6y = 4result = x if x &gt; y else yprint(result) 48. map （1）用法：map(func,list)第二个参数可以是list 或者其他集合类型意思是 对list执行func函数，然后返回一个map对象r = map(func,list) #返回的是 map对象（2）可以根据需要将map对象（如r）转换为需要的类型。123456789list_x = [1, 2, 3, 4, 5, 6, 8]def square(x): return x * x# for x in list_x:# print(square(x))result = map(square,list_x)print(result) #返回一个map对象print(list(result)) #转换为list类型输出 map和lambda（匿名函数）的结合使用场景123456list_x = [1, 2, 3, 4, 5, 6, 8]list_y = [1, 2, 3, 5, 6, 7, 9]result = map(lambda x, y: x + y ,list_x, list_y)print(result) #返回一个map对象print(list(result)) #转换为list类型输出 注： map可以接受多个参数（* iterables），map后面的参数集合长度（如这里的list_x, list_y）最好一样，如果不一致，map会按照长度最小的计算。 49. reduce reduce函数用于连续计算，连续调用参数中的lambda表达式；第一个参数是函数，第二个参数是序列或者集合，第三个参数是初始值。 12345678910111213'''reduce :连续计算'''from functools import reducelist_x = [1,2,3,4,5,6,7]#主要用于连续计算，不只是累加。（连续调用lambda）r = reduce(lambda x, y: x + y,list_x) #这里相当于((((((1+2)+3)+4)+5)+6)+7)的计算过程，即求列表中元素的累加和print(r)list_y = ['1', '2', '3', 'python', '1','2', '3']r1 = reduce(lambda x, y: x + y, list_y, 'hello') #这里的第三个参数是指初始值，即在进行计算之前的值是初始值'hello'print(r1) 运行结果： 50. filter(过滤器) 12345678910111213'''filter:过滤器filter最重要的是判断True或者False,True则返回，False则过滤掉。'''list_x = [1,3,0,5,0,7,0,0,6]r1 = filter(lambda x: True if x &gt; 0 else False, list_x)print(r1)print(list(r1))#上述也可以简写为r2 = filter(lambda x: x, list_x)print(list(r2)) 51. 装饰器（难点） 编程原则：对修改是封闭的，对扩展是开放的。(1) 写在装饰器之前（未使用装饰器） 1234567891011121314import timedef f1(): print('This is a function1!')def f2(): print('This is a function2!')def print_time(func): print(time.time()) func()print_time(f1)print_time(f2) (2) 装饰器的实现 这里与（1）类似，没有体现出装饰器的特点和优势。123456789101112import timedef decorator(func): #实现装饰器要用到嵌套函数 def wrapper(): #通过wrapper封装实现不改变原来函数的新功能 print(time.time()) func() return wrapperdef f1(): print('This is a function1!')#这里改变了函数调用的方式f = decorator(f1)f() （3）装饰器的使用使用装饰器：在定义的函数前面加上”@decorator”1234567891011121314import timedef decorator(func): #实现装饰器要用到嵌套函数 def wrapper(): #通过wrapper封装实现不改变原来函数的新功能 print(time.time()) func() return wrapper#(1)使用装饰器一个最大的特点是：不用改变函数调用的方式。#(2)通过在f1()上面添加了一个装饰器就能添加新的功能，且不用改变f1()函数@decorator def f1(): print('This is a function1!')#使用装饰器后，就可以按照普通的函数调用方式就可以调用函数，并且也可以添加新功能f1() (4) 装饰器之优化：使用装饰器的函数引入多个参数 关键解决之道：在wrapper函数中引入可变参数12345678910111213141516171819import timedef decorator(func): #实现装饰器要用到嵌套函数 def wrapper(*args): #使用可变参数（*args），这样使用装饰器的函数传入的参数个数可以是多个。 print(time.time()) func(*args) return wrapper#使用装饰器一个最大的特点是：不用改变函数调用的方式。#通过在f1()上面添加了一个装饰器就能添加新的功能，且不用改变f1()函数@decorator def f1(param): #一个参数 print('This is a function1! '+ param)@decoratordef f2(param1,param2): #两个参数 print('This is a function2! '+ param1) print('This is a function2! '+ param2)#使用装饰器后，就可以按照普通的函数调用方式就可以调用函数，并且也可以添加新功能f1('Test function1_param')f2('Test function2_param1','Test function2_param2') (5) 装饰器之优化：使用装饰器的函数引入了多个参数，且引入了关键字可变参数12345678910111213141516171819202122232425262728293031'''装饰器：当使用装饰器的函数传入的参数包含关键字参数，只使用可变参数是不能引入关键字参数的， 除了使用可变参数（*args）还要使用关键字可变参数（**kw）的。'''import time#完整的装饰器实现方法def decorator(func): def wrapper(*agrs, **kw): #需要引入可变参数和关键字可变参数 print(time.time()) func(*agrs, **kw) return wrapper@decoratordef f1(f1_param1): print('This is function1! ' + f1_param1)@decoratordef f2(f2_param1, f2_param2): print('This is function2! ' + f2_param1) print('This is function2! ' + f2_param2)@decoratordef f3(f3_param1, f3_param2, **kw): #关键字可变参数 print('This is function3! ' + f3_param1) print('This is function3! ' + f3_param2) print('This is function3! ' + str(kw)) print('This is function3! ', kw)f1('Test function1_param1')f2('Test function2_param1', 'Test function2_param2')f3('Test function3_param1', 'Test function3__param2',a = 1,c= 'python', b = 'hello') 运行结果： 52. VSCode调试代码技巧F5 开始调试F10 单步调试F5 跳断点F11 进入函数或对象的内部 53. 爬虫思路 53. 爬虫一些拓展 (1) BeautifulSoup , Scrapy(2) 爬虫，反爬虫，反反爬虫(3) ip被封（多次爬取同一网站）(4) 代理IP库 54. Python中使用字典实现Switch… Case … 1234567891011121314151617181920212223242526272829'''在Python中利用字典实现switch...case...'''day = 2def get_sunday(): return 'Sunday'def get_monday(): return 'Monday'def get_thursday(): return 'Thursday'#当day为其他值的时候，返回Unknowndef get_unknown(): return 'Unknown'#字典中key对应的值为函数switcher = &#123; 0 : get_sunday, 1 : get_monday, 2 : get_thursday,&#125;#字典访问的方式有两种：（1）通过下标访问的方式； （2）通过get()方法访问的方式。result = switcher.get(day,get_unknown)() #当day的值为其他值时，调用get_unknown函数#print(switcher[day]) print(result) 55. 列表推导式、集合推导式、字典推导式、元组推导式 （1）列表推导式1234a = [1, 2, 3, 5, 6]b= [ i * i for i in a if i &gt; 4] #列表推导式print(b) # b是一个列表 （2）集合推导式123c = &#123;1, 2, 3, 5, 6&#125;d = &#123; i * i for i in c if i &gt; 4&#125; #集合推导式print(d) # d是一个集合 （3）字典编写列表推导式、字典推导式、元组表达式123456789101112131415a = &#123; '王二小' : 16, '刘胡兰' : 20, '嘎子' : 13&#125;b = [ key for key, value in a.items() ] #字典编写列表推导式,不能同时输出key和valuec = &#123; value:key for key, value in a.items()&#125; #字典推导式，可以更换key和value的顺序d = ( key for key, value in a.items()) #元组推导式，返回的是一个generator对象，因为元组是不可变，所以它的行为和列表、元组等一些可变序列不一样，且不建议使用元组推导式#d是一个generator对象for x in d: #遍历generator对象 print(x)print(b)print(c)print(d) 运行结果： 56. None （1）None表示空，表示不存在，和’’(空字符)、’[]’(空列表)、’False’是不一样的。123456789a = ''b = []c = Falseprint(a == None)print(b == None)print(c == None)print(a is None) 运行结果：（2）判空 a = None时使用’ not a ‘ 和‘ is None ’两者效果相同。1234567891011121314def func(): return Nonea = func()if not a: print('S')else: print('F')if a is None: print('S')else: print('F') 运行结果： a = [ ]时两者效果不同，所以判空时不要将这两种方式混为一谈。12345678910a = []if not a: print('S')else: print('F')if a is None: print('S')else: print('F') 运行结果：（3）判空推荐使用下面两种方式1if a: 1if not a: 这样无论是1234a = Nonea = ''a =[]a = False 这四种形式，以上两种判空操作都有效。所以不建议使用‘if a is None’判空。 57. 对象存在也不一定是True （1）对象存在，且不存在“ len__ ( )”内置方法和“ bool__ ( )”内置方法，则对象的bool值为True。123456789class Test(): pass test = Test()if test: print('S')else: print('F') 运行结果：输出 ‘S’（2）对象存在，且类中定义了“ len__ ( )”内置方法，则对象的bool值取决于“ len__ ( )”内置方法的返回值。| “ len__ ( )”内置函数的返回值 | 对象的bool值 || :——————————: |:———-:||0|False||非0|True||True|True||False|False|12345678910class Test(): def __len__(self): return 0test = Test()if test: print('S')else: print('F') 运行结果：输出‘F’ （3） 对象存在，且类中定义了“ len__ ( )”内置方法和“ bool__ ( )”内置方法，则对象的值取决于“ bool__ ( )”内置方法的返回值。（注意：“ bool__ ( )”的返回值只能是bool类型的，即True或False）| “ bool ( )”内置函数的返回值 | 对象的bool值 || :——————————: |:———-:||True|True||False|False|1234567891011class Test(): def __bool__(self): return True def __len__(self): return 0test = Test()if test: print('S')else: print('F') 运行结果：输出 ‘S’ 注：（1）永远不要认为对象不为None（即对象存在），对象的bool值就一定是True （2）“ bool ( )”内置方法是Python3中的方法，其在Python2中对应的内置方法是“ nonzero __ ( )”方法 （3）’’, [ ] , None 都表示False__ 58. 全局函数 1234567class Test(): #全局函数必须在类中定义了，在类外部才能被调用。 def __len__(self): return 0print(len('a009')) #调用全局函数len#打印结果为4，即字符串长度为4个 59. 装饰器的副作用 （1）未使用装饰器123456789101112131415import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper def f1(): ''' This is f1 ''' print(f1.__name__)f1() 运行结果：（2）使用装饰器时，会改变函数的名字，变为装饰器中的闭包函数名字12345678910111213141516import timedef decorator(func): def wrapper(): print(time.time()) func() return wrapper @decoratordef f1(): ''' This is f1 ''' print(f1.__name__)f1() 运行结果为： （3）使用装饰器，为了不改变函数的名字，应该在闭包函数前使用装饰器（”@wraps( func )”）。1234567891011121314151617import timefrom functools import wraps #首先要引入wraps装饰器def decorator(func): @wraps(func) #注意：不要忘了加func这个函数参数 def wrapper(): print(time.time()) func() return wrapper@decoratordef f1(): ''' This is f1 ''' print(f1.__name__)f1() 运行结果： 注:（1）加上（“@wraps（func）“）这个装饰器之所以可以使原函数的名字不改变，是因为这里的func事实上就是f1函数，使用wraps这个装饰器后，就把f1函数的信息复制给了wrapper闭包函数，虽然在执行f1函数时实际执行的函数是wrapper，所以原函数的名字仍然为f1；若没有这个wraps装饰器，则因为实际执行的函数是wrapper，所以原函数的名字被改变为wrapper。（2）函数名字改变会导致在后续编程中出现很多莫名其妙的错误，因此再使用装饰器的时候，要注意函数名字改变的问题。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-30T09:16:02.053Z","updated":"2019-04-19T01:15:50.356Z","comments":true,"path":"2018/01/30/hello-world/","link":"","permalink":"https://yuanziwoxin.github.io/2018/01/30/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}