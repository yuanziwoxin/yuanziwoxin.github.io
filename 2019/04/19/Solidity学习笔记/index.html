<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Solidity学习笔记 | YuanTechnology</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本人学习过程中整理的Solidity笔记，仅供参考！">
<meta name="keywords" content="Ethereum">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity学习笔记">
<meta property="og:url" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/index.html">
<meta property="og:site_name" content="YuanTechnology">
<meta property="og:description" content="本人学习过程中整理的Solidity笔记，仅供参考！">
<meta property="og:image" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/Solidity学习笔记.png">
<meta property="og:image" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/6c0db3c9538ce7d77d1515eec56b5731.png">
<meta property="og:image" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/ecd072b990c8c19ea00559dd3976b686.png">
<meta property="og:image" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/f356c1f6f0404c72d5d1658e5a27baa9.png">
<meta property="og:updated_time" content="2019-04-19T02:16:03.514Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Solidity学习笔记">
<meta name="twitter:description" content="本人学习过程中整理的Solidity笔记，仅供参考！">
<meta name="twitter:image" content="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/Solidity学习笔记.png">
    

    
        <link rel="alternate" href="/" title="YuanTechnology" type="application/atom+xml" />
    

    
        <link rel="icon" href="/images/favicon.jpg" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">YuanTechnology</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/images/avatar.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="st-default-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <script type="text/javascript">
(function(w,d,t,u,n,s,e) {w['SwiftypeObject']=n;w[n]=w[n]||function() {
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','g6shCyTigBeFsHDSSR-n','2.0.0');
</script>
<style>
    .st-ui-injected-overlay-container,
    .st-ui-injected-overlay-container *:not(select) {
        font-family: inherit !important;
    }
    section.st-ui-content.st-search-results a.st-ui-result .st-ui-type-heading {
        color:  !important;
    }
    .st-ui-injected-overlay-container .st-ui-header input[type="text"]:focus {
        border-bottom: 2px solid ;
    }
    .st-ui-injected-overlay-container .st-ui-footer a.st-ui-pagination-link {
        color: ;
    }
    .st-ui-injected-overlay-container .st-ui-footer a.st-ui-pagination-link span.st-ui-arrow {
        border-color: ;
    }
</style>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="st-default-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/images/avatar.jpg" />
            <h2 id="name">yuanziwoxin</h2>
            <h3 id="title">Web Developer &amp; Designer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Ji&#39;An, China</span>
            <a id="follow" target="_blank" href="https://github.com/yuanziwoxin/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                4
                <span>posts</span>
            </div>
            <div class="article-info-block">
                4
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/yuanziwoxin/" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class=tooltip>
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class=tooltip>
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class=tooltip>
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-Solidity学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Solidity学习笔记
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/04/19/Solidity学习笔记/">
            <time datetime="2019-04-19T01:35:02.000Z" itemprop="datePublished">2019-04-19</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Ethereum/">Ethereum</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>本人学习过程中整理的Solidity笔记，仅供参考！<br><img src="/2019/04/19/Solidity学习笔记/Solidity学习笔记.png" title="Learn Solidity and Ethereum"><br><a id="more"></a></p>
<p>[TOC]</p>
<h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>Solidity是一门静态类型语言，支持继承、库和复杂的用户自定义类型等特性。</p>
<h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><h2 id="1-地址（address）"><a href="#1-地址（address）" class="headerlink" title="1. 地址（address）"></a>1. 地址（address）</h2><ul>
<li>以太坊中的地址为160位，即20个字节大小，所以可以用一个uint160表示。</li>
<li><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="noopener">eip-55:有关验证地址的合法性</a></li>
<li>在合约内部，this表示当前合约本身，由于合约也是一个address类型（<strong>contract是从address继承的</strong>），所以this其实也是address类型的值。<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2. 类型转换"></a>2. 类型转换</h2><h3 id="1-隐式转换"><a href="#1-隐式转换" class="headerlink" title="(1) 隐式转换"></a>(1) 隐式转换</h3>（1）无符号整数（uint）可以转换为<strong>相同或更大尺寸</strong>的<strong>字节类型（bytes）</strong>,但是反过来不可以转换。<br>（2）任何可以转换为<strong>uint160</strong>类型的变量都可以转换为<strong>地址类型（address）</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract convert&#123;</span><br><span class="line">    int8  a = <span class="number">1</span>;</span><br><span class="line">    int16  b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 返回的类型必须是int16，如果返回int8类型会报错，这边运算符已经帮我们隐式转换了类型</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">int16</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">// a+b 的结果会隐式的转换为int16</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-显式转换"><a href="#2-显式转换" class="headerlink" title="(2)显式转换"></a>(2)显式转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int8  public  c = <span class="number">-2</span>;</span><br><span class="line">uint8  public  d = uint8(c);</span><br><span class="line"><span class="comment">// 此时的d为254</span></span><br><span class="line">uint  public e = uint(c);</span><br><span class="line"><span class="comment">// e = </span></span><br><span class="line"><span class="number">115792089237316195423570985008687907853269984665640564039457584007913129639934</span></span><br></pre></td></tr></table></figure>
<h2 id="3-发送以太币的两种方法"><a href="#3-发送以太币的两种方法" class="headerlink" title="3. 发送以太币的两种方法"></a>3. 发送以太币的两种方法</h2><h3 id="（1）transfer"><a href="#（1）transfer" class="headerlink" title="（1）transfer"></a>（1）transfer</h3><p>transfer从<strong>合约发起方</strong>向某个地址转入以太币，当<strong>地址无效</strong>或者<strong>发起方余额不足</strong>时，transfer将<strong>抛出异常</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向addressA转入一个以太币</span></span><br><span class="line">addressA.transfer(<span class="number">1</span> ether);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="comment">// 附带 gas</span></span><br><span class="line">addressA.transfer.gas(<span class="number">120000</span>)(<span class="number">1</span> ether);</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）send"><a href="#（2）send" class="headerlink" title="（2）send"></a>（2）send</h3><p>send是transfer的<strong>低级版本</strong>。当<strong>合约执行失败</strong>时，send会<strong>返回false</strong>。当转账成功，则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">owner.send(SOME_BALANCE); <span class="comment">// 失败时返回false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(owner.send(SOME_BALANCE))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用send时需注意以下三点：</p>
<ul>
<li>（1）send方法<strong>需包裹在if中</strong>，因为在调用send函数时，合约可能会有函数执行，这些函数<strong>可能会执行失败</strong>。</li>
<li>（2）在用send方法发送以太币之前，请先执行减少账户余额的操作，因为可能会有递归调用消耗完合约余额的风险。</li>
<li>（3）用户可以重载send方法。</li>
</ul>
<p><strong>总结：</strong><br>x.transfer(y)等价于if(!x.send(y)) throw; ,send是transfer的底层实现，建议尽可能使用transfer。</p>
<h2 id="4-字节数组"><a href="#4-字节数组" class="headerlink" title="4. 字节数组"></a>4. 字节数组</h2><h3 id="（1）固定长字节数组"><a href="#（1）固定长字节数组" class="headerlink" title="（1）固定长字节数组"></a>（1）固定长字节数组</h3><p>固定长度字节数组是以<strong>bytes加上数字后缀</strong>的方式定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a;  // byte 等同于bytes1 a</span><br><span class="line">bytes2 b;</span><br><span class="line"> ...</span><br><span class="line">bytes32 c;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p> <strong>索引访问</strong>：bytes1~bytes32 支持索引访问，但是这种索引访问是<strong>只读的</strong>，<strong>不能使用进行赋值</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes10  b</span><br><span class="line">b[0]   // 获取第1个字节</span><br><span class="line">b[1]   // 获取第2个字节</span><br><span class="line">...</span><br><span class="line">b[9]   // 获取第9个字节</span><br><span class="line"></span><br><span class="line">b[0] = x  // 不能使用索引的形式进行赋值，因为这种索引访问是只读的。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以将 <strong>byte[]</strong> 当作<strong>字节数组</strong>使用，但这种方式<strong>非常浪费存储空间</strong>，准确来说，是<strong>在传入调用时</strong>，<strong>每个元素会浪费 31 字节</strong>。 更好地做法是<strong>使用 bytes</strong>。</p>
<h3 id="（2）动态长度字节数组"><a href="#（2）动态长度字节数组" class="headerlink" title="（2）动态长度字节数组"></a>（2）动态长度字节数组</h3><h4 id="bytes：动态长度字节数组"><a href="#bytes：动态长度字节数组" class="headerlink" title="bytes：动态长度字节数组"></a>bytes：动态长度字节数组</h4><p>一种特殊的数组。bytes类似于byte[]，在外部函数作为参数时，会进行压缩打包以便节省空间，所以尽量用bytes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes m;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="string：动态长度字符数串"><a href="#string：动态长度字符数串" class="headerlink" title="string：动态长度字符数串"></a>string：动态长度字符数串</h4><ul>
<li>（1）字符串以UTF-8的形式编码</li>
<li>（2）类似bytes，但不提供长度和按索引的访问方式。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 字符串是双引号</span><br><span class="line">string n = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">// 不支持长度访问</span><br><span class="line">n.length</span><br><span class="line"></span><br><span class="line">// 不支持按索引访问</span><br><span class="line">n[0]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li><strong>（1）</strong> <strong>string不支持通过索引访问</strong>，但可以通过string类型的值转换为bytes类型的值，然后就可以使用索引访问字符串的特定字节。</li>
<li><strong>（2）</strong> 由于<strong>bytes类型的值是可读写的</strong>，所以要修改string类型的值，可以先将string类型的值<strong>转换为</strong>bytes类型的值，修改完后，再将bytes类型的值<strong>转换为</strong>string类型的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value2 = typename ( value1 );  //类型转换</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中typename表示类型名，如string、bytes等。</p>
</blockquote>
<p>string类型有一些缺陷：如，不能直接使用加号（+）进行连接，但可以通过bytes类型间接将两个或多个字符串连接起来。</p>
<p><strong>字符串连接的基本原理</strong>：</p>
<ul>
<li>（1）创建一个尺寸与所有参与连接的字符串尺寸之和相同的大字符串；</li>
<li>（2）将该大字符串转换为bytes类型；</li>
<li>（3）依次迭代参与连接的字符串，将字符串中的字符逐一添加到bytes类型的值中；</li>
<li>（4）将这个bytes类型的值转换为string类型的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// internal表示函数只能被合约内部调用，函数在合约外不可见</span><br><span class="line">function strConcat(string memory _str1,string memory _str2) internal pure returns(string memory) &#123;</span><br><span class="line">    // 先将string转化为bytes类型的值</span><br><span class="line">    bytes memory _bytesValue1 = bytes(_str1);</span><br><span class="line">    bytes memory _bytesValue2 = bytes(_str2);</span><br><span class="line">    // 创建一个能容纳_str1和_str2的string对象</span><br><span class="line">    string memory resultStr = new string(_bytesValue1.length + _bytesValue2.length);</span><br><span class="line">    // 创建与_str1和_str2总和同样尺寸的bytes对象</span><br><span class="line">    bytes memory resultBytes = bytes(resultStr);</span><br><span class="line"></span><br><span class="line">    uint index = 0;</span><br><span class="line"></span><br><span class="line">    for(uint i=0;i&lt;_bytesValue1.length;i++)&#123;</span><br><span class="line">        resultBytes[index++] = _bytesValue1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(uint i=0;i&lt;_bytesValue2.length;i++)&#123;</span><br><span class="line">        resultBytes[index++] = _bytesValue2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return string(resultBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-枚举类型（enum）"><a href="#5-枚举类型（enum）" class="headerlink" title="5. 枚举类型（enum）"></a>5. 枚举类型（enum）</h2><p>枚举是Solidity中的<strong>自定义数据类型</strong>。枚举<strong>可以显式转为整型</strong>，但是<strong>不能与整型隐式转换</strong>，枚举在一般程序中可以当作状态机使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义枚举类型（类型名为enumName）</span><br><span class="line">enum enumName&#123; value1, value2, ... , valueN&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个枚举类型名为Country的枚举类型，每一个枚举值都对应一个整数索引，China表示0，America表示1，以此类推。(不用添加分号)</span><br><span class="line">   enum Country &#123;China,America,Japan,Australia,Canada,South_Korea&#125;</span><br><span class="line">   </span><br><span class="line">   // 定义枚举Country类型的变量</span><br><span class="line">   Country country;</span><br><span class="line">   </span><br><span class="line">   // 赋值</span><br><span class="line">   country = Country.China;   //使用枚举值进行赋值</span><br><span class="line">   // or</span><br><span class="line">   country = Country(0);   //使用整数值进行赋值（必须显式类型转换）</span><br><span class="line">   </span><br><span class="line">   // 枚举可以显式转化为整型</span><br><span class="line">   uint currentCountry = uint(Country.China);  // 0</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>（1）在合约中可以使用<strong>枚举值</strong>设置枚举变量，也可以使用<strong>整数值</strong>设置枚举变量，<strong>后者必须显式类型转换</strong>。</li>
<li>（2）在<strong>remix</strong>环境中测试智能合约时，再输入测试数据时<strong>不能直接输入Country.China或其他枚举值</strong>，而<strong>需要输入整数</strong>，如0,1,2,3等。</li>
</ul>
</blockquote>
<h2 id="6-函数类型"><a href="#6-函数类型" class="headerlink" title="6. 函数类型"></a>6. 函数类型</h2><ul>
<li>（1）函数声明的类型称为<strong>函数类型</strong>。（注意：强调的是<strong>类型</strong>，类似我们常见的uint，string类型）</li>
<li>（2）<strong>函数类型</strong>可以作为函数参数<strong>的</strong>类型和函数返回值<strong>的</strong>类型。</li>
<li>（3）只要函数的<strong>参数个数</strong>、<strong>参数类型</strong>和<strong>函数返回值</strong>与<strong>函数类型</strong>一样，<strong>该函数</strong>就可以赋给一个<strong>函数类型</strong>的<strong>变量</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//func是一个函数类型变量</span><br><span class="line">function (uint,uint) returns(uint) func; </span><br><span class="line">function add(uint x, uint y) public returns(uint)&#123;</span><br><span class="line">return x+y;</span><br><span class="line">&#125;</span><br><span class="line">function test() public&#123;</span><br><span class="line">// 将add函数赋给函数类型变量func</span><br><span class="line">func = add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-函数和状态变量的4种可见性（访问权限）"><a href="#7-函数和状态变量的4种可见性（访问权限）" class="headerlink" title="7. 函数和状态变量的4种可见性（访问权限）"></a>7. 函数和状态变量的4种可见性（访问权限）</h2><h3 id="（1）访问权限"><a href="#（1）访问权限" class="headerlink" title="（1）访问权限"></a>（1）访问权限</h3><p><strong>（1）</strong> 如果<strong>不为函数指定访问权限</strong>，默认为<strong>public</strong>。<br><strong>（2）</strong> 合约的<strong>状态变量不能用external修饰</strong>，否则无法编译通过。<br><strong>（3）</strong> 如果<strong>不为状态变量指定访问权限</strong>，默认为<strong>internal</strong>。</p>
<p><strong>4类可见性（访问权限）</strong> 指定：</p>
<ul>
<li><strong>public</strong>：智能合约<strong>外部和内部</strong>都可使用的方法；<blockquote>
<p><strong>用public声明的状态变量</strong>，会自动产生一个<strong>getter函数</strong>。</p>
</blockquote>
</li>
<li><strong>internal</strong>：<strong>智能合约（包括派生合约，子合约）内部</strong>才可调用的方法；internal修饰的状态变量只能通过在内部的方式访问；</li>
<li><strong>external</strong>：可通过<strong>其他合约和交易</strong>进行调用的方法；<blockquote>
<p>（1）external函数不能直接调用，前面需要<strong>加this</strong>, 如this.func( )。<br>（2）在接收大量数据时，external函数有时更有效率。</p>
</blockquote>
</li>
<li><strong>private</strong>：只有<strong>在定义的合约中</strong>才可以调用，<strong>即使派生的合约也无法调用</strong>；用private修饰的状态变量也是如此，只在当前合约中可以访问（子合约也不能访问）。<h3 id="（2）getter函数"><a href="#（2）getter函数" class="headerlink" title="（2）getter函数"></a>（2）getter函数</h3>如果合约的<strong>状态变量使用public修饰</strong>，Solidity编译器会自动为状态变量生成一个<strong>与状态变量同名</strong>的<strong>getter函数</strong>，<strong>用于获取状态变量的值</strong>。</li>
<li>（1）如果状态变量的数据类型比较复杂，如mapping，生成的getter函数会带一些参数。</li>
<li>（2）尽管自动生成的getter函数使用external修饰，但是不能在合约内使用this调用。（尽管不会产生编译错误，但是无法成功部署合约）</li>
<li>（3）在合约内部，getter函数会解析为状态变量。<blockquote>
<p>例如，如果状态变量persons是mapping类型，在<strong>合约内部</strong>应该使用<strong>persons[key]</strong>, 而不是this.persons(key)形式。<br>不过在<strong>合约外部</strong>必须使用<strong>getter函数形式</strong>引用persons。（如：my.persons(key), my为创建的合约对象名，persons(key)即为状态变量persons的getter函数形式）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract MyContract&#123;</span><br><span class="line">    uint public data = 115;</span><br><span class="line">    string public personName;</span><br><span class="line">    uint public personAge;</span><br><span class="line">    struct Person&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint=&gt;Person) public persons;</span><br><span class="line"></span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        data = 200;</span><br><span class="line">        // 创建Person结构体的实例</span><br><span class="line">        Person memory person = Person(&#123;</span><br><span class="line">            name:&quot;Lebron James&quot;,</span><br><span class="line">            age:34</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将person添加到persons映射中</span><br><span class="line">        persons[10] = person;</span><br><span class="line">        // 在合约内部不能使用persons的getter函数形式引用persons映射，</span><br><span class="line">        // 所以尽管下面的代码编译不会出错，但无法成功部署在以太坊上。</span><br><span class="line">        // (string memory name,uint age) = this.persons(10);</span><br><span class="line">        </span><br><span class="line">        string memory name = persons[10].name;</span><br><span class="line">        uint age = persons[10].age;</span><br><span class="line">        personName = name;</span><br><span class="line">        personAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract GetterContract&#123;</span><br><span class="line">    MyContract my = new MyContract();</span><br><span class="line">    function getData() public view returns(uint)&#123;</span><br><span class="line">        // 调用MyContract合约中的data状态变量对应的getter函数（data函数）</span><br><span class="line">        return my.data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getPerson(uint id) public view returns(string memory,uint)&#123;</span><br><span class="line">        // 调用MyContract合约中persons状态变量对应的getter函数（persons函数）</span><br><span class="line">        // 该函数返回了多个值，这些值都是Person结构体的成员，</span><br><span class="line">        // 如果这个结构体的某个成员的数据类型无法通过函数返回（如mapping），那么系统就会忽略这个结构体成员。</span><br><span class="line">        (string memory name,uint age) = my.persons(id);</span><br><span class="line">        return (name,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="8-数组（稍有不同）"><a href="#8-数组（稍有不同）" class="headerlink" title="8. 数组（稍有不同）"></a>8. 数组（稍有不同）</h2><h3 id="（1）不同之处"><a href="#（1）不同之处" class="headerlink" title="（1）不同之处"></a>（1）不同之处</h3><p>solidity中数组与大多数语言稍有不同。具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个j行i列的二维数组（注意：定义的时候列在前面，行在后面）</span><br><span class="line">int[i][j]  arrayName;</span><br><span class="line">// 为数组arrayName的第m行第n列元素赋值，赋值为20.( 注意：赋值的时候，行在前面，列在后面)</span><br><span class="line">arrayName[m][n] = 20;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>（1）<strong>定义的时候列在前面，行在后面</strong>；</li>
<li>（2）<strong>赋值的时候，行在前面，列在后面</strong>；</li>
</ul>
</blockquote>
<h3 id="（2）注意事项（一）"><a href="#（2）注意事项（一）" class="headerlink" title="（2）注意事项（一）"></a>（2）注意事项（一）</h3><ul>
<li>对于<strong>storage</strong>数组，<strong>可以保存任意类型的数据</strong>，包括另一个数组、映射或结构体。</li>
<li>但对于<strong>memory</strong>数组，<strong>不能存储映射类型的数据</strong>。</li>
<li>如果作为 <strong>public 函数的参数</strong>，它<strong>只能是 ABI 类型</strong>。<h3 id="（3）注意事项（二）"><a href="#（3）注意事项（二）" class="headerlink" title="（3）注意事项（二）"></a>（3）注意事项（二）</h3></li>
<li><strong>（1）</strong> 如果你在一个空数组中使用.length，这将会造成向下溢出(不减小反而增大)，导致长度变为2^256-1。</li>
<li><strong>（2）</strong> 增加一个storage数组的长度花费的gas成本是一个常量值，因为storage变量被当作是zero-initialised(领初始化)的；<br>而减少storage数组的长度花费的gas成本至少是线性增长的（但事实上，大多数都要高于线性增长），因为其包含了显式清除要被删除的元素（类似于调用delete方法）。</li>
<li><strong>（3）</strong> 外部函数中暂时还不支持使用多维数组（但在public函数是支持的）。<h3 id="（4）数组成员"><a href="#（4）数组成员" class="headerlink" title="（4）数组成员"></a>（4）数组成员</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4>数组的成员变量length表示当前数组的长度。 </li>
<li>（1）动态数组可以在storage中通过改变成员变量 .length 改变数组大小（在memory中是不可以的）。 </li>
<li>（2）并<strong>不能通过访问超出当前数组长度</strong>的方式实现<strong>自动扩展数组的长度</strong>。</li>
<li>（3）一经创建，memory数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。</li>
<li>（4）如果你尝试<strong>改变</strong>一个<strong>不在storage中的非动态数组的大小</strong>，你将会收到一个“<strong>Value must be an Ivalue</strong>”的错误。<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4>storage的动态数组以及 bytes类型（字节数组）都有一个叫做 push 的成员函数，它用来添加新的元素到数组末尾。 这个函数将返回<strong>新的数组长度</strong>。<blockquote>
<p>注意：<strong>string即字节数组是没有push方法的</strong>。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>storage的动态数组和bytes数组（字节数组）都有一个叫做pop的成员函数，用于从数组的末尾删除元素。<br>其在删除元素的时候隐式地调用了delete方法。<br>注意：<strong>string即字节数组是没有pop方法的</strong>。</p>
<h3 id="（5）实例"><a href="#（5）实例" class="headerlink" title="（5）实例"></a>（5）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers; // 数组大小为2的20次方</span><br><span class="line">    // m_pairsOfFlags不是一对动态数组，而是一个数组元素为两个变量的动态数组（说白了就是其每个元素是一个长度为2的数组）</span><br><span class="line">    bool[2][] m_pairsOfFlags; // 列数为2，行数为动态的</span><br><span class="line"></span><br><span class="line">    // newPairs是一个数组元素为两个bool类型变量的动态数组（其每个元素是一个包含两个bool变量的数组）</span><br><span class="line">    function setAllFlagPairs(bool[2][] memory newPairs) public &#123;</span><br><span class="line">        // 将newPairs数组赋值给storage数组的m_pairsOfFlags,m_pairsOfFlags的值将会被newPairs中的值替换。</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct StructType &#123;</span><br><span class="line">        uint[] contents;</span><br><span class="line">        uint moreInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    StructType s;</span><br><span class="line"></span><br><span class="line">    function f(uint[] memory c) public &#123;</span><br><span class="line">        // 将类型为StructType结构体变量s的指针（引用）赋值给g</span><br><span class="line">        StructType storage g = s;</span><br><span class="line">        // 改变结构体变量g中的成员属性值，其实也在改变s中的成员属性值（因为s和g指向同一块数据区域）</span><br><span class="line">        g.moreInfo = 2;</span><br><span class="line">        // 将c的值赋值给g.contents（虽然g.contents不是一个局部变量，但它是某个局部变量的一个成员）</span><br><span class="line">        g.contents = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) public &#123;</span><br><span class="line">        // 访问一个不存在数组下标会抛异常</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA; // 将flagA赋值给第index行第0列的元素</span><br><span class="line">        m_pairsOfFlags[index][1] = flagB; // 将flagB赋值给第index行第1列的元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) public &#123;</span><br><span class="line">        // 如果所赋给的新长度值小于原数组长度值，则会把原数组在新长度之外的元素删除。</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() public &#123;</span><br><span class="line">        // 将数组清空</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // 与上面效果相同（清空数组）</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes memory data) public &#123;</span><br><span class="line">        // 字节数组（bytes）是不一样的,因为它们不是填充式存储，但是它们可以被当作和uint8[]一样对待。</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = 0x08;</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] memory flag) public returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag); // 向二维动态数组添加新元素（这里添加的元素是一个长度为2的数组），给二维数组增加一行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) public pure returns (bytes memory) &#123;</span><br><span class="line">        // 使用new关键字进行动态数组的创建</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line"></span><br><span class="line">        // 内联数组总是静态大小的，如果你只是使用字面量，则你必须提供至少一种类型。</span><br><span class="line">        arrayOfPairs[0] = [uint(1), 2];</span><br><span class="line"></span><br><span class="line">        // 创建一个动态数组</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(uint8(i));</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>参考：<a href="https://solidity.readthedocs.io/en/latest/types.html#arrays" target="_blank" rel="noopener">Array</a></p>
<h2 id="9-结构体（struct）"><a href="#9-结构体（struct）" class="headerlink" title="9. 结构体（struct）"></a>9. 结构体（struct）</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>结构体用于自定义数据类型，结构体成员可以是任何数据类型，甚至可以是结构体本身。</p>
<ul>
<li>（1）结构体<strong>可用于函数返回值</strong>，但是要在智能合约<strong>内部调用</strong>，否则会抛出异常。</li>
<li>（2）如果<strong>要返回结构体中成员的值</strong>，可以使用<strong>返回多个值的函数</strong>。<h3 id="（2）实例"><a href="#（2）实例" class="headerlink" title="（2）实例"></a>（2）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;= 0.7.0;</span><br><span class="line"></span><br><span class="line">contract StructContract_1&#123;</span><br><span class="line">    // 定义结构体类型</span><br><span class="line">    struct Job&#123;</span><br><span class="line">        uint id;</span><br><span class="line">        string name;</span><br><span class="line">        string company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Person&#123;</span><br><span class="line">        uint id;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        Job job; // 结构体类型中引用结构体变量（结构体变量作为结构体类型的成员）</span><br><span class="line">    &#125;</span><br><span class="line">    // Job public job;</span><br><span class="line">    // 声明一个Person类型的变量</span><br><span class="line">    Person  person;</span><br><span class="line">    </span><br><span class="line">    // 初始化结构体 </span><br><span class="line">    // 方法一：按照结构体中命名参数进行初始化</span><br><span class="line">    Person personA = Person(&#123;</span><br><span class="line">        id:10002,</span><br><span class="line">        name:&quot;Kobe Bryant&quot;,</span><br><span class="line">        age:39,</span><br><span class="line">        job:Job(&#123;   //结构体中包含结构体</span><br><span class="line">            id:102,</span><br><span class="line">            name:&quot;Basketball Player&quot;,</span><br><span class="line">            company:&quot;NBA&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    // 方法二：按照结构体中定义的顺序初始化</span><br><span class="line">    Job jobA = Job(103,&quot;NBA Retired Players&quot;,&quot;Home&quot;);</span><br><span class="line">    Person personB = Person(10003,&quot;Dwyane Wade&quot;,36,Job(104,&quot;LiNing Spokeman&quot;,&quot;LiNing&quot;));</span><br><span class="line">    Person personC = Person(10004,&quot;Chris Bosh&quot;,35,jobA);</span><br><span class="line">    //通过构造函数初始化结构体类型变量</span><br><span class="line">    constructor (uint personId,string memory name,uint age) public&#123;</span><br><span class="line">        // 初始化结构体变量</span><br><span class="line">        Job memory job = Job(&#123;</span><br><span class="line">            id:101,</span><br><span class="line">            name:&quot;Software Engineer&quot;,</span><br><span class="line">            company:&quot;Google&quot;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">       person = Person(&#123;</span><br><span class="line">            id:personId,</span><br><span class="line">            name:name,</span><br><span class="line">            age:age,</span><br><span class="line">            job:job</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改工作属性（修改结构体变量的值）</span><br><span class="line">    function setJob(string memory jobName,string memory company) public&#123;</span><br><span class="line">        // job.name = jobName;</span><br><span class="line">        // job.company = company;</span><br><span class="line">        person.job.name = jobName;</span><br><span class="line">        person.job.company = company;</span><br><span class="line">        // 重置为初始值，把struct中的所有变量的值设置为0，除了mapping类型</span><br><span class="line">        // delete person; //也须写在函数内部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 要用结构体当作返回值，必须将函数定义为internal，即合约内部可见（函数仅在合约内部可调用）</span><br><span class="line">    // 必须在内部调用（需要使用internal声明函数），否则会抛出异常</span><br><span class="line">    function getPerson() internal view returns(Person memory)&#123;</span><br><span class="line">        return person; // 返回构造体类型的值</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取人员的姓名、年龄、工作等信息（获取结构体的成员值）</span><br><span class="line">    function callGetPerson() public  returns(string memory,uint,string memory,string memory)&#123;</span><br><span class="line">        person = getPerson();</span><br><span class="line">        return (person.name,person.age,person.job.name,person.job.company);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 1,&quot;Lebron James&quot;,34    &quot;BasketBall Player&quot;,&quot;NBA&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="10-映射（mapping）"><a href="#10-映射（mapping）" class="headerlink" title="10. 映射（mapping）"></a>10. 映射（mapping）</h2><h3 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>映射与字典类似，<strong>通过key获取对应的value值</strong>。</p>
<ul>
<li><strong>key</strong>：可以是<strong>除了映射外</strong>的任何数据类型；</li>
<li><strong>value</strong>：任何数据类型；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(keyType=&gt;valueType) varName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="（2）实例-1"><a href="#（2）实例-1" class="headerlink" title="（2）实例"></a>（2）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract MappingContract&#123;</span><br><span class="line">    //声明映射类型的变量names</span><br><span class="line">    mapping(uint=&gt;string) public names;</span><br><span class="line">    // 定义Person结构体类型</span><br><span class="line">    struct Person&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        string job;</span><br><span class="line">    &#125;</span><br><span class="line">    //声明映射类型的变量persons</span><br><span class="line">    mapping(uint=&gt;Person) public persons;</span><br><span class="line">    // 通过合约的构造函数向映射变量names添加值</span><br><span class="line">    constructor (uint id,string memory name) public&#123;</span><br><span class="line">        names[id] = name; //映射变量的赋值</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据key值从映射类型变量中获取相应的value值</span><br><span class="line">    function getValue(uint id) public view returns(string memory)&#123;</span><br><span class="line">        return names[id];</span><br><span class="line">    &#125;</span><br><span class="line">    // 向映射类型变量中添加值</span><br><span class="line">    function addPerson(uint id,string memory name,uint age,string memory job) public&#123;</span><br><span class="line">        // 先初始化结构体</span><br><span class="line">        Person memory person = Person(&#123;</span><br><span class="line">            name:name,</span><br><span class="line">            age:age,</span><br><span class="line">            job:job</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        persons[id] = person; //增加一个person（向映射类型变量中添加值）</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据id(key)从persons映射获取Person对象，并通过返回多值函数返回Person结构体的成员</span><br><span class="line">    </span><br><span class="line">    function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123;</span><br><span class="line">        // 返回多个值</span><br><span class="line">        // 方法一：多返回值函数可以通过定义具体的函数返回值接收多个返回值，而不使用return关键字</span><br><span class="line">        name = persons[id].name;</span><br><span class="line">        age = persons[id].age;</span><br><span class="line">        job = persons[id].job;</span><br><span class="line">        // 方法二：使用return关键字(多个返回值，需用括号括起来)</span><br><span class="line">        // return (persons[id].name,persons[id].age,persons[id].job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试数据</span><br><span class="line">// 1001,&quot;Lebron James&quot;</span><br><span class="line">// 1002,&quot;Dwyane Wade&quot;,36,&quot;NBA Player&quot;</span><br><span class="line">// 1003,&quot;Kobe Bryant&quot;,39,&quot;World Cup Spokeman&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实例中有提到两种不同的方式返回多个值</p>
<h2 id="11-函数参数和函数返回值"><a href="#11-函数参数和函数返回值" class="headerlink" title="11.函数参数和函数返回值"></a>11.函数参数和函数返回值</h2><h3 id="（1）函数参数"><a href="#（1）函数参数" class="headerlink" title="（1）函数参数"></a>（1）函数参数</h3><p>在函数中，如果某个<strong>参数未使用</strong>，<strong>只需保留参数类型</strong>，参数名可以省略。</p>
<h3 id="（2）函数返回值"><a href="#（2）函数返回值" class="headerlink" title="（2）函数返回值"></a>（2）函数返回值</h3><p><strong>函数返回值</strong>可以直接指定<strong>返回值类型</strong>，也可以<strong>为返回值指定变量名</strong>，声明返回值类型的方式与声明函数参数的方式相同，所以也可以将函数返回值称为<strong>函数输出和参数</strong>。</p>
<ul>
<li>返回值类型要使用returns指定，多个返回值类型中间用逗号（ , ）分隔；</li>
<li>如果<strong>为函数返回值指定变量名</strong>，<strong>可以不使用return返回</strong>，直接<strong>为函数输出参数变量赋值</strong>即可。</li>
</ul>
</blockquote>
<p>返回多个值的两种方法</p>
<ul>
<li><p><strong>方法一：</strong> 函数可以通过设置<strong>多个具体的函数返回值变量</strong>接收多个返回值，而不使用return关键字，就可实现多个值的返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> function getPerson(uint id) public view returns(string memory name,uint age,string memory job)&#123;</span><br><span class="line">        name = persons[id].name;</span><br><span class="line">        age = persons[id].age;</span><br><span class="line">        job = persons[id].job;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法二：</strong> 使用return关键字(多个返回值，需用括号括起来)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> function getPerson(uint id) public view returns(string memory, uint ,string memory)&#123;</span><br><span class="line">        return (persons[id].name,persons[id].age,persons[id].job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-调用其他合约中的函数"><a href="#12-调用其他合约中的函数" class="headerlink" title="12. 调用其他合约中的函数"></a>12. 调用其他合约中的函数</h2><h3 id="（1）定义-2"><a href="#（1）定义-2" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>当前合约中的函数调用其他合约中的函数的两个前提条件：</p>
<ul>
<li>（1）<strong>被调用函数所在的合约</strong>必须<strong>已经成功部署在以太坊网络上</strong>（或在本地的测试环境）。</li>
<li>（2）需要知道<strong>被调用函数所在的合约的地址</strong>。<h3 id="（2）实例-2"><a href="#（2）实例-2" class="headerlink" title="（2）实例"></a>（2）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// CallOtherContract.sol</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">注意：</span><br><span class="line"> （1）在部署FunCallContract之前，必须先部署FactorialContract合约，否则就无法获得FactorialContract的地址。</span><br><span class="line"> （2）部署完FactorialContract合约之后，将FactorialContract合约的地址作为FunCallContract合约的构造参数</span><br><span class="line">       传入FunCallContract合约，然后部署FunCallContract合约。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 用于计算阶乘的合约</span><br><span class="line">contract FactorialContract&#123;</span><br><span class="line">    // 计算阶乘的函数</span><br><span class="line">    function getFactorial(uint n) public returns(uint)&#123;</span><br><span class="line">        if(n==0 || n==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return getFactorial(n-1)*n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 调用FactorialContract.getFactorial函数计算阶乘</span><br><span class="line">contract FunCallContract&#123;</span><br><span class="line">    FactorialContract factorial;</span><br><span class="line">    //在构造函数中创建FactorialContract合约的实例，</span><br><span class="line">    // 必须通过FunCallContract构造函数的参数指定FactorialContract合约的地址。</span><br><span class="line">    constructor(address addr) public&#123;</span><br><span class="line">        factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算阶乘</span><br><span class="line">    function jiecheng(uint n) public returns(uint)&#123;</span><br><span class="line">        return factorial.getFactorial(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-通过new关键字创建合约对象"><a href="#12-通过new关键字创建合约对象" class="headerlink" title="12. 通过new关键字创建合约对象"></a>12. 通过new关键字创建合约对象</h2><p>通过new关键字创建合约对象<strong>最大的优势</strong>：<br><strong>不需要</strong>先部署被调用函数所在的合约，并先获取被调用函数所在合约的地址，<strong>然后</strong>才能部署调用函数的合约。</p>
<blockquote>
<p>换句话说就是，合约A调用合约B中的函数还需要先部署合约B是比较麻烦的。但是通过new关键字创建合约对象，则不需要部署合约B就可以调用B中的函数。</p>
</blockquote>
<p>相对于上面CallOtherContract.sol的代码,只需将FunCallContract的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(address addr) public&#123;</span><br><span class="line">        factorial = FactorialContract(addr);//实例化合约实例的时候需要传入其合约的地址</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CallOtherContract_1.sol</span><br><span class="line">constructor() public&#123;</span><br><span class="line">         // 通过new关键字创建合约对象（此时不需要传入该合约对象的合约地址）</span><br><span class="line">        factorial = new FactorialContract();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其他不用变化。</p>
<blockquote>
<p>这样使用new关键字创建合约对象，就不需要先部署FactorialContract合约，并获取其合约的地址后，然后才能部署FunCallContract合约，在其合约内部调用其FactorialContract合约中的函数。<br>这里可以直接部署FunCallContract合约。</p>
<h2 id="13-函数的命名参数"><a href="#13-函数的命名参数" class="headerlink" title="13. 函数的命名参数"></a>13. 函数的命名参数</h2><p>在solidity语言中<strong>调用函数时可以指定命名参数</strong>，通过命名参数，<strong>可以不按<em>被调用函数的参数的定义的顺序</em>传入参数值</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.16 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">// 命名参数的使用</span><br><span class="line">contract NamedParameter&#123;</span><br><span class="line">    function sub(int n1,int n2) public pure returns(int) &#123;</span><br><span class="line">        return n1-n2;</span><br><span class="line">    &#125;</span><br><span class="line">    function fun() public pure returns(int)&#123;</span><br><span class="line">        // 通过函数的命名参数，可以不按被调用函数中的参数的定义顺序进行赋值</span><br><span class="line">        // 命名参数要通过&#123;...&#125;传递，有点类似于javascript中的对象</span><br><span class="line">        return sub(&#123;n2:66,n1:32&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="15-函数多返回值解构和元组赋值"><a href="#15-函数多返回值解构和元组赋值" class="headerlink" title="15. 函数多返回值解构和元组赋值"></a>15. 函数多返回值解构和元组赋值</h2><ul>
<li>（1）<strong>多返回值解构</strong>：如果函数返回多个值，可以支持将<strong>多个返回值</strong>分别赋给<strong>相应数目的变量</strong>。</li>
<li>（2）<strong>元组赋值</strong>：指赋值运算符（=）左侧和右侧都有n个变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.24 &lt;=0.7.0; //注意：只有0.4.24及以上版本才支持多返回值解构和元组赋值</span><br><span class="line"></span><br><span class="line">contract AssignmentContract&#123;</span><br><span class="line">    uint[] data;</span><br><span class="line">    function mulValueFun() public pure returns(uint,bool,uint)&#123;</span><br><span class="line">        return (2018,true,2019);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function assignment() public returns(uint xx,uint yy,bool bb,uint length)&#123;</span><br><span class="line">        // 多返回值解构赋值，x、b和y分别等于mulValueFun函数的3个返回值</span><br><span class="line">        (uint x,bool b,uint y) = mulValueFun();</span><br><span class="line">        // 交换x和y的值</span><br><span class="line">        (x,y)=(y,x);  //元组赋值</span><br><span class="line">        // 这里只指定了一个变量（data.length）,所以mulValueFun函数的其他返回值会被忽略</span><br><span class="line">        (data.length,,) = mulValueFun(); //未指定的变量，通过逗号（,）将位置留着</span><br><span class="line">        // 重新设置y变量的值</span><br><span class="line">        y = 123;</span><br><span class="line">        // 设置返回值</span><br><span class="line">        xx = x;</span><br><span class="line">        yy = y;</span><br><span class="line">        bb = b;</span><br><span class="line">        length = data.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="16-变量声明和作用域"><a href="#16-变量声明和作用域" class="headerlink" title="16. 变量声明和作用域"></a>16. 变量声明和作用域</h2><h3 id="（1）0-5-0版本之前"><a href="#（1）0-5-0版本之前" class="headerlink" title="（1）0.5.0版本之前"></a>（1）0.5.0版本之前</h3><p>在Solidity 0.5.0之前，Solidity语言的作用域规则继承自JavaScript。<br>在if、while、for循环中定义的变量仍然作用于{…}外面，也就是说 <strong>{…}中声明的变量</strong>，在 <strong>{…}外仍然可以使用</strong>。<br>换句话说，就是无论{..}内还是{…}外，都不能有同名的变量。</p>
<h3 id="（2）0-5-0版本之后"><a href="#（2）0-5-0版本之后" class="headerlink" title="（2）0.5.0版本之后"></a>（2）0.5.0版本之后</h3><p>在Solidity 0.5.0之后, 开始支持声明块（{…}）变量，也就是在 <strong>{…}中声明的变量只在{…}中有效</strong>，这就意味着在多个{…}中可以声明多个同名的变量。</p>
<h2 id="17-错误处理"><a href="#17-错误处理" class="headerlink" title="17. 错误处理"></a>17. 错误处理</h2><p>Solidity语言有3种与错误处理相关的函数：</p>
<ul>
<li>（1）<strong>require</strong>：用于<strong>校检外部输入</strong>，如函数的参数、调用外部函数的返回值等。</li>
<li>（2）<strong>assert</strong>：用于<strong>校检合约的内部错误</strong>。</li>
<li>（3）<strong>revert</strong>：<strong>抛出错误</strong>。</li>
</ul>
<p>Solidity语言的<strong>错误处理</strong>与数据库中的<strong>事务回滚</strong>类似，<strong>一旦发生错误</strong>，<strong>以前做的所有操作都将回滚</strong>，因为合约很可能涉及到转账等敏感操作，所以一旦有任何异常，必须全部恢复到最初的状态，以避免数据不一致的情况发生。</p>
<h2 id="18-全局变量"><a href="#18-全局变量" class="headerlink" title="18. 全局变量"></a>18. 全局变量</h2><h3 id="（1）block变量"><a href="#（1）block变量" class="headerlink" title="（1）block变量"></a>（1）block变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract BlockContract&#123;</span><br><span class="line">    function getBlockInfo() public view returns(address coinbase,uint difficulty,</span><br><span class="line">    uint gaslimit,uint number,uint timestamp)&#123;</span><br><span class="line">        coinbase = block.coinbase; //获取挖出当前区块的矿工的地址；</span><br><span class="line">        difficulty = block.difficulty; //获取当前区块的挖矿难度；</span><br><span class="line">        gaslimit = block.gaslimit; //获取当前区块的gas限制；</span><br><span class="line">        number = block.number; //获取当前区块的编号</span><br><span class="line">        timestamp = block.timestamp; //获取当前区块的时间戳（从Unix epoch即Unix纪元，从1970年1月1日开始）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）msg变量"><a href="#（2）msg变量" class="headerlink" title="（2）msg变量"></a>（2）msg变量</h3><ul>
<li>（1）执行函数包含参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract MsgContract&#123;</span><br><span class="line">    // 获取相关的系统信息</span><br><span class="line">    function getMsgInfo(uint x) public payable returns(bytes memory data,uint gas,address sender,bytes4 sig,uint value)&#123;</span><br><span class="line">        data = msg.data; //获取当前执行函数的调用数据（包含函数标识，即sha3散列值的前8位，若执行函数有参数，则还包含参数值）</span><br><span class="line">        // gas = msg.gas; // msg.gas已经被gasleft()函数取代</span><br><span class="line">        gas = gasleft(); // 获取剩余的gas</span><br><span class="line">        sender = msg.sender; // 获取当前执行函数的调用地址</span><br><span class="line">        sig = msg.sig; // 获取当前执行函数的标识（sha3散列值的前8位）</span><br><span class="line">        value = msg.value; // 当前被发送的wei的数量（使用该属性的函数要使用payable关键字修饰）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<img src="/2019/04/19/Solidity学习笔记/6c0db3c9538ce7d77d1515eec56b5731.png" title="The steps are as follows">
<p><strong>结果：</strong><br><img src="/2019/04/19/Solidity学习笔记/ecd072b990c8c19ea00559dd3976b686.png" title="The result_1 are as follows"></p>
<ul>
<li>（2）执行函数不包含参数：</li>
</ul>
<p>把上述合约函数中的getMsgInfo(uint x)修改为getMsgInfo( ), 即去掉函数的参数。<br><strong>结果：</strong><br><img src="/2019/04/19/Solidity学习笔记/f356c1f6f0404c72d5d1658e5a27baa9.png" title="The result_2 are as follows"></p>
<blockquote>
<ul>
<li>msg.data表示当前执行函数的调用数据，包含函数标识（即sha3散列值的前8位）。如果<strong>执行函数包含参数</strong>，则<strong>其还包含参数值</strong>。</li>
<li>msg.sig表示当前执行函数的标识（即sha3散列值的前8位）。</li>
<li>换句话说，如果<strong>执行函数不包含参数</strong>，则msg.data(只包含函数标识)与msg.sig（函数标识）是<strong>一样的</strong>。</li>
</ul>
</blockquote>
<p>例如，若当前执行的函数是getMsgInfo( ),那么可以使用下面的Node.js代码获取该函数sha3散列值的前8位。该值与msg.data属性返回的值相同(即都是只包含函数标识)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'Web3'</span>);</span><br><span class="line">web3 = <span class="keyword">new</span> Web3( );</span><br><span class="line"><span class="comment">// 由于sha3函数返回的值前两位是表示十六进制的0x,所以从第3个字符开始截取，截取的长度为8位</span></span><br><span class="line">sign = web3.sha3(<span class="string">"getMsgInfo( )"</span>).substr(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sign); <span class="comment">//输出 4c668374</span></span><br></pre></td></tr></table></figure></p>
<h3 id="（3）其他全局变量"><a href="#（3）其他全局变量" class="headerlink" title="（3）其他全局变量"></a>（3）其他全局变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.22 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">// 其他全局变量</span><br><span class="line">contract OtherGlobalContract&#123;</span><br><span class="line">    // 获取其他全局变量的值</span><br><span class="line">    function getOtherGlobal() public view returns(bytes32 hash,uint nowTime,uint gasPrice,address origin)&#123;</span><br><span class="line">        // 获取指定区块的哈希值（要传入区块号）</span><br><span class="line">        hash = blockhash(1001);</span><br><span class="line">        // 获取当前区块的时间戳（与block.timestamp属性返回的值相同）</span><br><span class="line">        nowTime = now;</span><br><span class="line">        // 获取交易的gas价格</span><br><span class="line">        gasPrice = tx.gasprice;</span><br><span class="line">        // 获取发送交易的地址</span><br><span class="line">        origin = tx.origin; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-自定义修饰符（modifier）"><a href="#19-自定义修饰符（modifier）" class="headerlink" title="19. 自定义修饰符（modifier）"></a>19. 自定义修饰符（modifier）</h2><p>modifier常用于<strong>在函数执行前检查某种前置条件是否满足</strong>，modifier是一种合约属性，<strong>可以被继承</strong>（子合约可以使用父合约中定义的modifier），同时<strong>还可被派生的合约重写</strong>（override）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier  modiferName&#123;</span><br><span class="line">    //校检代码</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>校检代码</strong>用于校检<strong>使用自定义修饰符的函数</strong>，后面必须跟一个下划线（_）,而且下划线后面跟分号（ ; ）。如果通过校检，将<strong>使用该定义修饰符的函数的函数体</strong>插入到下划线的位置。也可以认为自定义修饰符其实就是<strong>多个函数相同代码的抽象</strong>，除了校检代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">contract OwnerContract&#123;</span><br><span class="line">    address owner;</span><br><span class="line">    // 保存部署合约的账号</span><br><span class="line">    constructor() public&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义用于检测msg.sender是否为部署合约的账号，如果不是，终止执行函数</span><br><span class="line">    modifier onlyOwner&#123;</span><br><span class="line">        require(msg.sender == owner,&quot;Only owner can call this function.&quot;);</span><br><span class="line">        _;   // 如果校检通过，会将使用onlyOwner函数的函数体插到这个位置。</span><br><span class="line">    &#125;</span><br><span class="line">    // 校检地址是否可以为空</span><br><span class="line">    // 当输入的_address为0x0000000000000000000000000000000000000000(0x后40个0)，会抛出“_address can not be 0!”</span><br><span class="line">    modifier notNull(address _address)&#123;</span><br><span class="line">        require(_address != address(0),&quot;_address can not be 0!&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一个函数可以有多个修饰符，多个修饰符之间用空格或回车分隔，修饰符的生效顺序与定义顺序是一样的</span><br><span class="line">    // 修改合约所有者</span><br><span class="line">    function changeOwner(address newOwner) notNull(newOwner) onlyOwner() public&#123;</span><br><span class="line">        owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从OwnerContract继承 </span><br><span class="line">contract AddContract is OwnerContract&#123;</span><br><span class="line">    // 使用onlyOwner修饰函数</span><br><span class="line">    function add(uint m,uint n)  public view onlyOwner() returns(uint)&#123;</span><br><span class="line">        return m+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract RestrictContract&#123;</span><br><span class="line">    uint public mm;</span><br><span class="line">    uint public nn;</span><br><span class="line">    // 用于校检 m是否大于或等于n,如果不满足条件，相当于将使用restrict1函数的函数体删除</span><br><span class="line">    modifier restrict1(uint m,uint n)&#123;</span><br><span class="line">        if(m&gt;=n)&#123; //如果不满足条件，相当于将使用restrict1函数的函数体删除</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 除了校检m是否大于n外，还将m和n分别保存在mm和nn变量中</span><br><span class="line">    modifier restrict2(uint m,uint n)&#123;</span><br><span class="line">        require(m&gt;=n,&quot;m can not less than n&quot;);</span><br><span class="line">        mm = m;</span><br><span class="line">        nn = n;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从RestrictContract合约继承</span><br><span class="line">contract SubContract is RestrictContract&#123;</span><br><span class="line">    // 使用restrict1修饰sub1函数</span><br><span class="line">    function sub1(uint m,uint n) public pure restrict1(m,n) returns(uint)&#123;</span><br><span class="line">        return m-n;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用restrict2修饰sub2函数</span><br><span class="line">    function sub2(uint m,uint n) public restrict2(m,n) returns(uint)&#123;</span><br><span class="line">        return m-n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="20-pure和view"><a href="#20-pure和view" class="headerlink" title="20. pure和view"></a>20. pure和view</h2><h3 id="（1）pure"><a href="#（1）pure" class="headerlink" title="（1）pure"></a>（1）pure</h3><p>使用<strong>pure</strong>关键字修饰的函数<strong>不允许<em>读写</em> 状态变量</strong>，否则会编译出错。<br>下面几种情况会被认为是读写状态变量，在这些情况下，用pure关键字修饰函数就会编译错误：</p>
<ul>
<li>（1）直接读取状态变量；</li>
<li>（2）访问 <strong>this.balance</strong>或 <strong><address>.balance</address></strong>；</li>
<li>（3）<strong>访问任何block、tx、msg变量中的成员</strong>，但<strong>msg.sig和msg.data除外</strong>。</li>
<li>（4）<strong>调用任何没有使用pure修饰的函数</strong>，哪怕是这个函数中确实没有读写任何状态变量。</li>
<li>（5）内嵌用于操作状态变量的汇编代码的函数。<h3 id="（2）view"><a href="#（2）view" class="headerlink" title="（2）view"></a>（2）view</h3>使用<strong>view</strong>关键字修饰函数时，表示该函数<strong>不会修改状态变量</strong>。<br>下面几种情况表明函数会修改合约的状态变：</li>
<li>（1）只写修改状态变量；</li>
<li>（2）<strong>触发事件</strong>；</li>
<li>（3）<strong>创建其他合约的实例</strong>；</li>
<li>（4）调用<strong>selfdestruct</strong>函数销毁合约；</li>
<li>（5）<strong>通过call函数方发送以太币</strong>；</li>
<li>（6）调用<strong>任何未标记view或pure函数</strong>；</li>
<li>（7）使用底层的call函数；</li>
<li>（8）内嵌用于操作状态变量的汇编代码的函数；<blockquote>
<p><strong>需要注意的是</strong>：用view修饰的函数<strong>并不会阻止函数中修改状态变量</strong>，<strong>只是</strong>在用view修饰的函数中修改状态变量<strong>会出现警告</strong>。（不报错，只出现警告）</p>
<h2 id="21-fallback函数（回调函数）"><a href="#21-fallback函数（回调函数）" class="headerlink" title="21. fallback函数（回调函数）*"></a>21. fallback函数（回调函数）*</h2><p>fallback函数：一个没有函数名、参数和返回值的函数。必须用external进行修饰。<br>在下面两种情况下会调用fallback函数：</p>
</blockquote>
</li>
<li><p><strong>（1）</strong> 合约中<strong>没有匹配的函数标识</strong>。</p>
<blockquote>
<p>换句话说，就是</p>
<ol>
<li>该合约没有其他函数；</li>
<li>调用合约时，如果没有匹配上该合约中的任何一个函数，就会调用回调函数。</li>
</ol>
</blockquote>
</li>
<li><p><strong>（2）</strong> <strong>合约接收到以太币（交易中没有附带任何其他数据）</strong>，也会调用回调函数。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>这种情况下，fallback函数要使用<strong>payable</strong>关键字修饰，否则<strong>给包含fallback函数的合约发送以太币时</strong>会<strong>出现编译错误</strong>。</li>
<li>即使 <strong>fallback 函数不能有参数</strong>，<strong>仍然可以</strong>使用 <strong>msg.data</strong> 来<strong>获取随调用提供的任何有效数据</strong>。</li>
</ol>
</blockquote>
</li>
</ul>
<p>另外，还需注意以下几点：</p>
<ul>
<li><strong>（1）</strong> 如果调用者想调用一个不存在的函数，fallback函数将会被执行。</li>
<li><strong>（2）</strong> 如果你<strong>只想为了接收以太币</strong>而实现fallback函数，你需要<strong>增加一些校检</strong>（如 <strong>require(msg.data.length == 0 )</strong> ）去避免一些无效的调用。</li>
<li><strong>（3）</strong> 一个没有定义fallback函数（回调函数）的合约直接接收以太币（没有函数调用，如使用send或transfer），则会抛出一个异常，并返还以太币（有些行为在Solidity V0.4.0之前有些不同）。因此如果你要使你的合约接收以太币，你就必须实现一个被payable修饰的fallback函数。<blockquote>
<p>一个没有 payable fallback 函数的合约，可以作为 <strong>coinbase transaction</strong> （又名 miner block reward ）<strong>的接收者</strong>或者作为 <strong>selfdestruct 的目标</strong>来接收以太币。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract Test&#123;</span><br><span class="line">    uint x;</span><br><span class="line">    // （1）给这个合约发送任何消息都会调用这个函数（因为合约没有其他函数）</span><br><span class="line">    // 定义一个fallback函数，在该函数中设置了状态变量x。</span><br><span class="line">    // （2）向这个合约发送以太币将会抛出一个异常，因为这个回调函数没有用“payable”修饰符修饰。</span><br><span class="line">    function() external&#123; x=101; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Sink&#123;</span><br><span class="line">    // 定义了一个fallback函数，该函数使用payable修饰，表明可以接受其他地址发过来的以太币。</span><br><span class="line">    function() external payable&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller&#123;</span><br><span class="line">    function callTest(Test test) public returns(bool)&#123;</span><br><span class="line">        // 这里调用一个不存在的函数，由于匹配不到函数，所以将调用Test合约中的回调函数。</span><br><span class="line">        (bool success,) = address(test).call(abi.encodeWithSignature(&quot;nonExitingFunction()&quot;));</span><br><span class="line">        require(success);</span><br><span class="line">        // address(test)不允许直接调用“send”方法，因为“test”没有被“payable”修饰的回调函数。</span><br><span class="line">        // 其必须通过“uint160”进行一个中间转换，然后再转换为“address payable”类型才能调用“send”方法。</span><br><span class="line">        address payable testPayable = address(uint160(address(test)));</span><br><span class="line">        // 如果某人发送以太币给那个合约，这笔交易将会失败（例如，这里将会返回false）</span><br><span class="line">        return testPayable.send(2 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callSink(address payable sinkAddress) public returns(bool)&#123;</span><br><span class="line">        Sink sink = Sink(sinkAddress);</span><br><span class="line">        // 如果向Sink合约发送以太币时发送成功，Sink中的fallback函数会被调用</span><br><span class="line">        return address(sink).send(5 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>参考：<a href="https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function" target="_blank" rel="noopener">Fallback Function</a></p>
<h2 id="22-函数重载"><a href="#22-函数重载" class="headerlink" title="22. 函数重载"></a>22. 函数重载</h2><h3 id="（1）定义-3"><a href="#（1）定义-3" class="headerlink" title="（1）定义"></a>（1）定义</h3><p><strong>函数重载</strong>是指一个合约中定义了<strong>多个函数名相同</strong>，但<strong>参数个数和类型不同</strong>的函数。（不考虑返回值）</p>
<blockquote>
<p><strong>需要注意的是</strong>：<br>如果<strong>函数参数类型是可以转换的</strong>，例如合约和address，Solidity编译器就<strong>会认为它们是同一个数据类型</strong>，因此会产生<strong>编译错误</strong>。</p>
</blockquote>
<h3 id="（2）实例-3"><a href="#（2）实例-3" class="headerlink" title="（2）实例"></a>（2）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">// 拥有4个同名的重载函数</span><br><span class="line">contract OverloadContract1&#123;</span><br><span class="line">    // 拥有2个uint类型的参数</span><br><span class="line">    function add(uint m,uint n) public pure returns(uint)&#123;</span><br><span class="line">        return m+n;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有参数</span><br><span class="line">    function add() public pure returns(uint)&#123;</span><br><span class="line">        return 11+22;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有一个bool类型参数</span><br><span class="line">    function add(bool b) public pure returns(bool)&#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    // 有3个uint类型的参数</span><br><span class="line">    function add(uint l,uint m,uint n) public pure returns(uint)&#123;</span><br><span class="line">        return l+m+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从表面上看第一个和第二个test函数的参数不一样，其实是一样的。因为合约A本身就是一个address类型</span><br><span class="line">// 所以OverloadContract2合约编译会失败，因为前两个test函数无法实现函数重载</span><br><span class="line">contract OverloadContract2&#123;</span><br><span class="line">    // 函数重载失败</span><br><span class="line">    function test(address addr) public view returns(uint)&#123;</span><br><span class="line">        return addr.balance;</span><br><span class="line">    &#125;</span><br><span class="line">    // 函数重载失败,具体报错：Function overload clash during conversion to external types for arguments.</span><br><span class="line">    // function test(A a) public view returns(uint)&#123;</span><br><span class="line">    //     return address(a).balance;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // 函数重载成功</span><br><span class="line">    function test(A a,uint b) public view returns(uint,uint)&#123;</span><br><span class="line">        return (address(a).balance,b);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-事件（event）"><a href="#23-事件（event）" class="headerlink" title="23. 事件（event）"></a>23. 事件（event）</h2><h3 id="（1）定义-4"><a href="#（1）定义-4" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>如果将合约部署在<strong>TestRPC环境或者以太坊网络</strong>上，在<strong>执行以太坊函数时</strong>是<strong>无法直接获得函数的返回值的</strong>，但是可以<strong>通过事件将计算结果返回给客户端</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event EventName( typeName  parameter,... );</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）实例-4"><a href="#（2）实例-4" class="headerlink" title="（2）实例"></a>（2）实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract EventContract&#123;</span><br><span class="line">    // 定义MyEvent事件</span><br><span class="line">    event MyEvent(</span><br><span class="line">        uint m,</span><br><span class="line">        uint n,</span><br><span class="line">        uint results</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function add(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        uint results = m+n;</span><br><span class="line">        // 使用emit指令触发MyEvent事件，并通过事件参数传递m、n和m+n的计算结果（传递到客户端）</span><br><span class="line">        emit MyEvent(m,n,results);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-合约继承"><a href="#24-合约继承" class="headerlink" title="24. 合约继承"></a>24. 合约继承</h2><p>合约继承，使用<strong>is</strong>关键字指定父合约。</p>
<ul>
<li><strong>（1）</strong> Solidity合约<strong>支持多继承</strong>，如果要指定多个合约，合约之间<strong>用逗号（ , ）分隔</strong>。</li>
<li><strong>（2）</strong> 尽管<strong>可以指定多个父合约</strong>，但是<strong>只会创建一个合约实例</strong>，将其他父合约中的代码复制到这个合约实例中。</li>
<li><strong>（3）</strong> 如果<strong>多个父合约实现了同样的函数</strong>，那么<strong>以最后一个父合约的函数为准</strong>。<h2 id="25-合约构造函数"><a href="#25-合约构造函数" class="headerlink" title="25. 合约构造函数"></a>25. 合约构造函数</h2></li>
<li>（1）老版本的solidity语言中，合约的构造函数与普通函数类似，<strong>只是函数名与合约名相同</strong>。</li>
<li><p>（2）新版本的solidity语言中，使用<strong>constructor</strong>作为<strong>构造函数的名字</strong>。</p>
<blockquote>
<p>这样做的好处是，一旦改变了合约的名字，也不用修改其构造函数的名字。</p>
</blockquote>
</li>
<li><p>（3）合约构造函数允许使用<strong>public</strong>或<strong>internal</strong>修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.4.20 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">contract Contract1&#123;</span><br><span class="line">    uint public a;</span><br><span class="line">    // 带参数的构造函数，假设用internal修饰</span><br><span class="line">    constructor(uint _a) internal&#123;</span><br><span class="line">        a = _a; //用来初始化状态变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从Contract1继承，并将构造函数重新用public修饰，变成外部可访问的构造函数。</span><br><span class="line">// 由于Contract1合约的构造函数有一个参数，所以在继承时需要指定Contract1合约构造函数的参数值。</span><br><span class="line">contract Contract2 is Contract1(100)&#123;</span><br><span class="line">    constructor() public&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Contract3 is Contract1&#123;</span><br><span class="line">    uint aa;</span><br><span class="line">    uint bb;</span><br><span class="line">    // 如果构造参数的参数需要用某些变量设置，如构造函数的参数，可以在构造函数后面指定父合约构造函数的参数值</span><br><span class="line">    constructor(uint _a,uint _b) Contract1(_a*_b) public&#123;</span><br><span class="line">        aa = _a;</span><br><span class="line">        bb = _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="26-抽象合约"><a href="#26-抽象合约" class="headerlink" title="26. 抽象合约"></a>26. 抽象合约</h2><p><strong>抽象合约</strong>： 至少有一个函数没有实现的合约。</p>
<blockquote>
<p>如果合约从一个抽象合约继承，而且<strong>没有全部实现</strong>抽象合约中的函数，那么这个合约就会继承<strong>这些未实现的函数</strong>，所以这个合约也是<strong>抽象合约</strong>。（说白了，就是这个合约继承了一个抽象合约，但是还有些继承自抽象合约的函数没有实现，于是这个合约也就有了一些函数没有实现，所以这个合约也就是抽象合约了。）</p>
</blockquote>
<p><strong>抽象合约</strong>通常来实现<strong>多态</strong>，也就是<strong>用抽象合约的多个子合约创建多个实例</strong>，将这些实例赋给<strong>抽象合约类型</strong>的<strong>变量</strong>。<br>由于<strong>这些子合约都实现了抽象合约中的函数</strong>，所以<strong>调用抽象合约中的函数</strong>会根据<strong>抽象合约类型变量的值</strong>不同，<strong>调用结果</strong>也不同，这就是称为<strong>多态</strong>。（调用同一个函数，会有多种不同表现形态）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    在MyContract合约中的test1和test2函数中分别创建了 MyContract1和MyContract2的实例，</span><br><span class="line">    且将这两个合约的实例都赋值给了AbstractContract类型（抽象合约类型）的变量。</span><br><span class="line">    在test1和test2函数中都调用了AbstractContract合约（父合约）中的add函数，且输入相同的实参值，</span><br><span class="line">    不过返回结果却不一样，这就是多态。</span><br><span class="line">    实际上，本质上调用的是MyContract1（子合约）和MyContract2合约（子合约）中的add函数。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">contract AbstractContract&#123;</span><br><span class="line">    // add函数没有实现</span><br><span class="line">    function add(uint m,uint n) public returns(uint);</span><br><span class="line">    // 完整实现了sub函数</span><br><span class="line">    function sub(int m,int n) public pure returns(int)&#123;</span><br><span class="line">        return m-n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该合约从AbstractContract继承(即MyContract1是AbstractContract的一个子合约)</span><br><span class="line">contract MyContract1 is AbstractContract&#123;</span><br><span class="line">    // 实现了抽象合约中的add函数</span><br><span class="line">    function add(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        return m+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该合约从AbstractContract继承(即MyContract2是AbstractContract的另一个子合约)</span><br><span class="line">contract MyContract2 is AbstractContract&#123;</span><br><span class="line">    // 实现了抽象合约中的add函数</span><br><span class="line">    function add(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        return 4*(m+n);  //不同于MyContract1中add函数的实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 该合约从MyContract1 继承，即继承了add函数和sub函数</span><br><span class="line">contract MyContract is MyContract1&#123;</span><br><span class="line">    function test1(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        // 创建MyContract1 合约的实例</span><br><span class="line">        AbstractContract abstractContract = new MyContract1();</span><br><span class="line">        // 实际是调用了MyContract1 合约中的add函数</span><br><span class="line">        return abstractContract.add(m,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test2(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        // 创建MyContract2 合约的实例</span><br><span class="line">        AbstractContract abstractContract = new MyContract2();</span><br><span class="line">        // 实际是调用了MyContract1 合约中的add函数</span><br><span class="line">        return abstractContract.add(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="27-接口"><a href="#27-接口" class="headerlink" title="27. 接口"></a>27. 接口</h2><p>接口与抽象合约类似，但是<strong>不能实现任何函数</strong>。（即所有接口中的方法都是未实现的）<br>此外，接口还有如下限制：</p>
<ul>
<li>（1）<strong>不能继承其他合约或接口</strong>；</li>
<li>（2）不能定义构造函数；</li>
<li>（3）不能定义变量；</li>
<li>（4）不能定义结构体；</li>
<li>（5）不能定义枚举类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface interfaceName&#123;</span><br><span class="line">    //抽象方法（未被实现的方法）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意：<br>（1）<strong>接口应该定义在合约的外部</strong>（与合约是同一等级）；<br>（2）接口中定义的方法必须被<strong>external</strong>修饰；</p>
</blockquote>
<p>合约实现接口的方法与继承合约或抽象合约的方法类似, 使用is关键字.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;=0.5.0 &lt;=0.7.0;</span><br><span class="line"></span><br><span class="line">// 定义接口(定义在合约外面)</span><br><span class="line">interface MyInterface&#123;</span><br><span class="line">    function add(uint m,uint n) external returns(uint);</span><br><span class="line">    function sub(int m,int n) external returns(int);</span><br><span class="line">&#125;</span><br><span class="line">// InterfaceContract实现了MyInterface</span><br><span class="line">contract InterfaceContract is MyInterface&#123;</span><br><span class="line">    function add(uint m,uint n) public returns(uint)&#123;</span><br><span class="line">        return m+n;</span><br><span class="line">    &#125;</span><br><span class="line">    function sub(int m,int n) public returns(int)&#123;</span><br><span class="line">        return m-n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="28-gas-limit和gas-price"><a href="#28-gas-limit和gas-price" class="headerlink" title="28. gas limit和gas price"></a>28. gas limit和gas price</h2><h3 id="（1）gas-limit"><a href="#（1）gas-limit" class="headerlink" title="（1）gas limit"></a>（1）gas limit</h3><ul>
<li><strong>（1）</strong> gas limit 表示完成转账交易最大消耗的gas数，如果超过这个gas数，交易就会失败，整个交易过程都会回滚。</li>
<li><strong>（2）</strong> gas limit 主要是为了<strong>防止</strong>由于发布交易<strong>消耗过多的gas</strong>。<h3 id="（2）gas-price"><a href="#（2）gas-price" class="headerlink" title="（2）gas price"></a>（2）gas price</h3></li>
<li>表示你愿意<strong>为单位gas支付的费用</strong>，以gwei为单位表示。<br><code>1 gwei = 10^9 wei</code><h3 id="（3）两者的作用"><a href="#（3）两者的作用" class="headerlink" title="（3）两者的作用"></a>（3）两者的作用</h3></li>
<li>（1）在交易中gasPrice是由发起交易人来决定的，每个矿工接收到交易请求之后，会根据gasPrice的高低来决定是否要打包进区块。</li>
<li>（2）每个交易中必须包含gas limit和gas price的值。gas limit代表了这个交易执行过程中最多被允许消耗的gas数量。</li>
<li>（3）gas limit和gas price 代表着交易发送者愿意为执行交易支付的wei的最大值。<br><code>付款金额（单位 wei）= Gas数量 × GasPrice</code></li>
<li>（4）交易执行完成后，如果实际消耗的gas小于gaslimit，那么剩余的gas会以Ether的方式返回给交易发起者。</li>
<li>（5）如果在交易过程中，<strong>实际消耗的gas大于gas limit</strong>,那么就会出现“gas不足”的错误，这种情况下交易会被终止，交易之前的所有修改的状态会被回滚，同时在<strong>交易执行过程中所消耗的gas</strong>是<strong>不会回退给交易发起者的</strong>。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/" data-id="cjunm0xhk0008fgv67bx8enq1" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/">Comments</a>
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2018/02/02/C语言笔记/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">C语言学习笔记</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</section>
    

</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/04/19/Solidity学习笔记/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/04/19/Solidity学习笔记/" class="title">Solidity学习笔记</a></p>
                            <p class="item-date"><time datetime="2019-04-19T01:35:02.000Z" itemprop="datePublished">2019-04-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/02/02/C语言笔记/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/02/02/C语言笔记/" class="title">C语言学习笔记</a></p>
                            <p class="item-date"><time datetime="2018-02-02T02:30:02.000Z" itemprop="datePublished">2018-02-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/02/01/Python笔记（一）/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/02/01/Python笔记（一）/" class="title">Python笔记（一）</a></p>
                            <p class="item-date"><time datetime="2018-02-01T10:03:02.000Z" itemprop="datePublished">2018-02-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/01/30/Hexo Quick Start/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/01/30/Hexo Quick Start/" class="title">Hexo Quick Start</a></p>
                            <p class="item-date"><time datetime="2018-01-30T03:05:09.000Z" itemprop="datePublished">2018-01-30</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ethereum/">Ethereum</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Ethereum/" style="font-size: 10px;">Ethereum</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2019 yuanziwoxin<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. 
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_config = function () {
        
            this.page.url = 'https://yuanziwoxin.github.io/2019/04/19/Solidity学习笔记/';
        
        this.page.identifier = 'Solidity学习笔记';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'yuan-technology' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>